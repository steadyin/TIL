# 5. 스프링 MVC - 구조 이해

## 5.1 스프링 MVC 전체 구조

![img_58](https://user-images.githubusercontent.com/79847020/159222809-a2d07eb8-1d77-4171-a5d8-7680fc7d2fff.png)

![img_59](https://user-images.githubusercontent.com/79847020/159222821-08b41d50-e132-4f28-9f75-e1ee4c97fb8e.png)

### 직접 만든 프레임워크 -> 스프링 MVC 비교 

* FrontController -> DispatcherServlet
  * 스프링 애플리케이션 요청 시 요청을 받아 핸들러 매핑 정보를 참고해서 각 핸들러에 연결해주는 역할.
```java
@WebServlet(name = "fronControllerServletV5", urlPatterns = "/front-controller/v5/*")
public class FrontControllerServletV5 extends HttpServlet {
```
 
* 핸들러 매핑 정보(HandlerMappingMap) -> HandlerMapping
```java
@WebServlet(name = "fronControllerServletV5", urlPatterns = "/front-controller/v5/*")
public class FrontControllerServletV5 extends HttpServlet {
    private final Map<String, Object> handlerMappingMap = new HashMap<>();
    private final List<MyHandlerAdapter> handlerAdapters = new ArrayList<>();
    
    private void initHandlerMappingMap() {
      handlerMappingMap.put("/front-controller/v5/v3/members/new-form", new MemberFormControllerV3());
      handlerMappingMap.put("/front-controller/v5/v3/members/save", new MemberSaveControllerV3());
      handlerMappingMap.put("/front-controller/v5/v3/members", new MemberListControllerV3());
    
      handlerMappingMap.put("/front-controller/v5/v4/members/new-form", new MemberFormControllerV4());
      handlerMappingMap.put("/front-controller/v5/v4/members/save", new MemberSaveControllerV4());
      handlerMappingMap.put("/front-controller/v5/v4/members", new MemberListControllerV4());
    }

    private Object getHandler(HttpServletRequest request) {
        String requestURI = request.getRequestURI();
        return handlerMappingMap.get(requestURI);
    }
    ...생략    
```
 
* 핸들러 어댑터(MyHandlerAdapter) -> HandlerAdapter
```java
public interface MyHandlerAdapter {
    boolean supports(Object handler);

    ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler);
}

public class ControllerV3HandlerAdapter implements MyHandlerAdapter {
...구현 생략...
}

public class ControllerV4HandlerAdapter implements MyHandlerAdapter {
...구현 생략...
}

@WebServlet(name = "fronControllerServletV5", urlPatterns = "/front-controller/v5/*")
public class FrontControllerServletV5 extends HttpServlet {

    private final Map<String, Object> handlerMappingMap = new HashMap<>();
    private final List<MyHandlerAdapter> handlerAdapters = new ArrayList<>();

    private void initHandlerAdapters() {
        handlerAdapters.add(new ControllerV3HandlerAdapter());
        handlerAdapters.add(new ControllerV4HandlerAdapter());
    }

    private MyHandlerAdapter getHandlerAdapter(Object handler) {
        for (MyHandlerAdapter adapter : handlerAdapters) {
            if (adapter.supports(handler)) return adapter;
        }
        throw new IllegalArgumentException("handler adapter를 찾을 수 없습니다. " + handler);
    }
    ...생략
}
```

* ModelView -> ModelAndView
  * 핸들러 어댑터가 핸들러를 처리한 결과를 ModelView 객체로 반환한다.
  * View 정보와 Model 정보가 담겨있다.
```java
@Getter
@Setter
public class ModelView {
    private String viewName;
    private Map<String, Object> model = new HashMap<>();

    public ModelView(String viewName) {
        this.viewName = viewName;
    }
}
```

* viewResolver -> ViewResolver
  * XMLViewResolver, ThymeleafViewResolver
```java
    private MyView viewResolver(String viewName) {
        MyView view = new MyView("/WEB-INF/views/" + viewName + ".jsp");
        return view;
    }
```

* MyView -> View
```java
public class MyView {
    private String viewPath;

    public MyView(String viewPath) {
        this.viewPath = viewPath;
    }
    
    public void render(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        modelToRequest(model, request);

        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}
```

### DispatcherServlet 구조 살펴보기

org.springframework.web.servlet.DispatcherServlet

스프링 MVC도 프론트 컨트롤러 패턴으로 구현되어 있다. 스프링 MVC의 프론트 컨트롤러가 바로 디스패처 서블릿(DispatcherServlet)이다. 이 디스패처 서블릿이 바로 스프링 MVC의 핵심이다. 

DispatcherServlet 서블릿 등록
* DispatcherServlet도 부모 클래스에서 HttpServlet을 상속 받아서 사용하고 서블릿으로 동작한다.
  * DispatcherServlet -> FrameworkServlet -> HttpServletBean -> HttpServlet
* 스프링부트는 DispatcherServlet을 서블릿으로 자동으로 등록하면서 모든 경로(urlPatterns="/")에 매핑한다.
* 참고로 스프링은 자세한 것이 우선순위가 높다. 그래서 추가로 상세한 서블릿을 등록하면 그 서블릿이 URL에 매핑된다.

요청 흐름
* 서블릿이 호출되면 HttpServlet이 제공하는 service()가 호출된다.
* 스프링 MVC는 DispatcherServlet의 부모인 FrameworkServlet에서 service()를 오버라이드 해두었다. 즉 FrameworkServlet의 service()를 시작으로 여러 메소드를 거쳐 DispatcherServlet.doDispatch()가 호출된다.
* doDispatcher의 흐름을 따라가보자.
  1. 핸들러 조회
  2. 핸들러 어댑터 조회 - 핸들러를 처리할 수 있는 어댑터
  3. 핸들러 어댑터 실행 
  4. 핸들러 어댑터를 통해 핸들러 실행
  5. ModelAndView 반환
  6. 뷰 랜더링 시작
  7. ViewResolver를 통해서 View 찾기
  8. View 반환
  9. View 랜더링

DispatcherServlet.doDispatch()
```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    ModelAndView mv = null;
        
    // 1. 핸들러 조회
    mappedHandler = getHandler(processedRequest);
    if (mappedHandler == null) {
        noHandlerFound(processedRequest, response);
        return;
    }
        
    // 2. 핸들러 어댑터 조회 - 핸들러를 처리할 수 있는 어댑터
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
        
    // 3. 핸들러 어댑터 실행 -> 4. 핸들러 어댑터를 통해 핸들러 실행 -> 5. ModelAndView 반환 
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        
    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
}

private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {
    // 뷰 렌더링 호출
    render(mv, request, response);
}

protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
    View view;
    String viewName = mv.getViewName(); 
    
    // 6. 뷰 리졸버를 통해서 뷰 찾기, 7. View 반환
    view = resolveViewName(viewName, mv.getModelInternal(), locale, request); 
    
    // 8. 뷰 렌더링
    view.render(mv.getModelInternal(), request, response);
}
```

![image](https://user-images.githubusercontent.com/79847020/159222683-f80bc1f1-532a-4522-8a14-2d50c00ef075.png)

동작 순서
1. 핸들러 조회 : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
2. 핸들러 어댑터 조회 : 핸드러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. 핸들러 어댑터 실행 : 핸들러 어댑터를 실행한다.
4. 핸들러 실행 : 핸들러 어댑터가 실제 핸들러를 실행한다.
5. ModelAndView 반환 : 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.
6. viewResolver 호출 : 뷰 리졸버를 찾고 실행한다.
   1. JSP의 경우 : InteranlResourceViewResolver가 자동 등록되고, 사용된다.
7. View 반환 : 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
   1. JSP의 경우 InternalResourceView(JstlView)를 반환하는데 내부에 forward() 로직이 있다.
8. 뷰 렌더링 : 뷰를 통해서 뷰를 렌더링 한다.

인터페이스 살펴보기
* 스프링 MVC의 큰 강점은 DispatcherServlet 코드의 변경 없이, 원하는 기능을 변경하거나 확장할 수 있다는 점이다. 지금까지 설명한 대부분을 확장 가능할 수 있게 인터페이스로 제공한다.
* 이 인터페이스들만 구현해서 DispatcherServlet에 등록하면 여러분만의 컨트롤러를 만들 수도 있다.

주요 인터페이스 목록
* 핸들러 매핑 : org.springframework.web.servlet.HandlerMapping
* 핸들러 어댑터 : org.springframework.web.servlet.HandlerAdapter
* 뷰 리졸버 : org.springframework.web.servlet.ViewResolver
* 뷰 : org.springframework.web.servlet.View

정리
* 스프링를 다 파악하는 것은 쉽지 않다. 그래도 핵심 동작 방식을 알아두어야 향후 문제가 발생했을 때 어떤 부분에서 문제가 발생했는지 쉽게 파악하고 문제를 해결할 수 있다. 그리고 확장 포인트가 필요할 때, 어떤 부분을 확장해야할지 감을 잡을 수 있다. 

## 5.2 핸들러 매핑과 핸들러 어댑터

### Controller 인터페이스

과거 버전 스프링 컨트롤러 인터페이스
```java
public interface Controller {
    ModelAndView handleREquest(HttpServletRequest request, HttpServletResponse response) throws Exception;
}
```

스프링도 처음에는 형식적인 컨트롤러를 제공했다. 

과거 버전 컨트롤러
```java
@Component("/springmvc/old-controller")
public class OldController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handleRequest");
        return new ModelAndView("new-form");
    }
}
```

@Component : 클래스를 스프링 빈으로 등록한다. "/springmvc/old-controller"이 빈 이름이다. 빈의 이름으로 URL을 매핑할 것이다.

이 컨트롤러가 호출되려면 다음 2가지가 필요하다. 
1. HandlerMapping(핸들러 매핑) 
   * 핸들러 매핑에서 이 컨트롤러를 찾을 수 있어야 한다.
   * 스프링 빈의 이름으로 핸들러를 찾을 수 있는 핸들러 매핑이 필요하다.
2. HandlerAdapter(핸들러 어댑터)
   * 핸들러 매핑을 통해서 찾은 핸들러를 실행할 수 있는 핸들러 어댑터가 필요하다.
   * Controller 인터페이스를 실행할 수 있는 핸들러 어댑터를 찾고 실행해야 한다.

스프링은 이미 대부분의 필요한 핸들러 매핑과 핸들러 어댑터를 구현해두었다. 개발자가 직접 핸들러 매핑과 핸들러 어댑터를 만드는 일은 거의 없다.

### 스프링 부트가 자동 등록하는 핸들러 매핑과 핸들러 어댑터

HandlerMapping 
0 = RequestMappingHandlerMapping - 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = BeanNameUrlHandlerMapping - 스프링 빈의 이름으로 핸들러를 찾는다.

HandlerAdapter
0 = RequestMappingHandlerAdapter - 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = HttpRequestHandlerAdapter - HttpRequestHandler 처리
2 = SimpleControllerHandlerAdapter - Controller 인터페이스(애노테이션X. 과거에 사용)

1. 핸들러 매핑으로 핸드럴 조회
   1. HandlerMapping을 순서대로 실행해서 핸들러를 찾는다.
   2. 이 경우 빈 이름으로 핸들러를 찾아야 하기 때문에 이름 그대로 빈 이름으로 핸들러를 찾아주는 BeanNameUrlHandlerMapping이 실행에 성공하고 핸들러인 OldController을 반환한다.

2. 핸들러 어댑터 조회
   1. HandlerAdapter의 supports()를 순서대로 호출한다.
   2. SImpleControllerHandlerAdapter가 Controller 인터페이스를 지원하므로 대상이 된다.

3. 핸들러 어댑터 실행
   1. DispatcherServlet이 조회한 SimpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘겨준다.
   2. SimpleCOntrollerHandlerAdatper는 핸들러 OldController을 내부에서 실행하고 그 결과를 반환한다.

### HttpRequestHandler

HttpRequestHandler 핸들러는 서블릿과 가장 유사한 형태의 핸들러이다.
```java
public interface HttpRequestHandler {
    void handleRequest(httpServletRequest request, HttpServletResponse response) throws ServletException IOException;
}
```

MyHttpRequestHandler
```java
@Component("/springmvc/request-handler")
public class MyHttpRequestHandler implements HttpRequestHandler {

    @Override
    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("MyHttpRequestHandler.handleRequest");
    }
}
```

http://localhost:8080/springmvc/request-handler

정리 - HttpRequestHandler 핸들러매핑, 핸들러어댑터
HandlerMapping - BeanNameUrlHandlerMapping
HandlerAdapter - HttpRequestHandlerAdapter

### @RequestMapping 기반 Controller

스프링은 애노테이션 기반 실용적인 컨트롤러를 만들었는데 바로 @RequestMapping 애노테이션을 사용하는 컨트롤러이다. @RequestMapping의 이름을 따서 HandlerMapping과 HandlerAdapter는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter이다. 

정리 - @RequestMapping 기반 컨트롤러
HandlerMapping - RequestMappingHandlerMapping
HandlerAdapter - RequestMappingHandlerAdapter

## 5.3 뷰 리졸버

```java
@Component("/springmvc/old-controller")
public class OldController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handleRequest");
        return new ModelAndView("new-form");
    }
}
```

뷰를 사용할 수 있도록 return new ModelAndView("new-form");을 추가하고 application.properties에 뷰관련 설정을 해주자. 

application.properties
```java
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

### 뷰 리졸버 - InternalResourceViewResolver

스프링부트는 InternalResourceViewResolver 뷰 리졸버를 자동으로 등록하는데 이때 application.properties에 등록한 spring.mvc.view.prefix, spring.mvc.view.suffix 설정 정보를 사용해서 등록한다. 권장하지는 않지만 return new ModelAndView("/WEB-INF/views/new-form.jsp")과 같이 작성해도 동작한다.

http://localhost:8080/springmvc/old-controller

### 뷰 리졸버 동작 방식

스프링부트가 자동 등록하는 뷰 리졸버
* 1 - BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. 
* 2 - InternalResourceViewREsolver : JSP를 처리할 수 있는 뷰를 반환한다.

1. 핸들러 어댑터 호출
   * 핸들러 어댑터를 통해 new-form이라는 논리 뷰 이름을 획득한다.
2. ViewResolver 호출
   * new-form이라는 뷰 이름으로 viewResolver를 순서대로 호출한다.
   * BeanNameViewResolver는 new-form이라는 스프링 빈으로 등록된 뷰를 찾는다.
   * InternalResourceResolver가 호출된다.
3. InternalResourceViewResolver
   * 이 뷰 리졸버는 InternalResourceView를 반환한다.
4. 뷰 - InternalResourceView
   * InternalResourceView는 JSP처럼 포워드 forward()를 호출해서 처리할 수 있는 경우에 사용한다.
5. view.render()
   * view.render()가 호출되고 InternalREsourceView는 forward()를 사용해서 JSP를 실행한다.

다른 뷰는 실제 뷰를 렌더링하지만 JSP의 경우 forward() 통해서 해당 JSP로 이동해야 렌더링이 된다. JSP를 제외한 나머지 뷰템플릿들은 forward()과정 없이 바로 렌더링 된다.

Thymeleaf 뷰 템플릿을 사용하면 ThymeleafViewResolver를 등록해야 한다. 

## 5.4 스프링 MVC - 시작하기

스프링이 제공하는 컨트롤러는 애노테이션 기반으로 동작해서 매우 유연하고 실용적이다. 

@RequestMapping 
* 스프링은 애노테이션을 활용한 매우 유연하고 실용적인 컨트롤러를 만들었는데 이것이 바로 @RequestMapping 애노테이션을 사용하는 컨트롤러이다. 
HandlerMapping과 HandlerAdapter은 RequestMappingHandlerMapping, RequestMappingHandlerAdapter을 사용한다. 앞서 보았듯이 우선순위가 가장 높은데 실무에서 99.9% 이 방식의 컨트롤러를 사용한다.

SpringMemberFormControllerV1
```java
@Controller
public class SpringMemberFormControllerV1 {
    @RequestMapping("/springmvc/v1/members/new-form")
    public ModelAndView process() {
        return new ModelAndView("new-form");
    }
}
```

@Controller
* 스프링이 자동으로 스프링 빈으로 등록한다.
* 내부에 @Component가 선언되어 있어 컴포넌트 스캔대상이 된다.
* 스프링 MVC에서 애노테이션 기반 컨트롤러로 인식한다.

@RequestMapping
* 요청 정보를 매핑한다.

ModelAndView
* 모델과 뷰 정보를 담아서 반환하면 된다.

RequestMappingHandlerMapping
* 스프링 빈 중에서 @RequestMapping 또는 @Controller가 클래스 레벨에 적용 되어 있는 경우 매핑 정보로 인식한다.

따라서 다음과 같이 작성해도 정상 동작한다.

```java
@Component
@RequestMapping
public class SpringMemberFormControllerV1 {
    ...
}
```

SpringMemberSaveControllerV1
```java
@Controller
public class SpringMemberSaveControllerV1 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @RequestMapping("/springmvc/v1/members/save")
    public ModelAndView process(HttpServletRequest request, HttpServletResponse response) {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        ModelAndView mv = new ModelAndView("save-result");
        mv.addObject("member", member);
        return mv;
    }
}
```

mv.addObject("member", member);
* 스프링이 제공하는 ModelAndView를 통해 Model 데이터를 추가할 때는 addObject()를 사용하면 된다. 이 데이터를 뷰 렌더링시에 사용된다.

SpringMemberListControllerV1
```java
@Controller
public class SpringMemberListControllerV1 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @RequestMapping("/springmvc/v1/members")
    public ModelAndView process(HttpServletRequest request, HttpServletResponse response) {

        List<Member> members = memberRepository.findAll();

        ModelAndView mv = new ModelAndView("members");
        mv.addObject("members", members);

        return mv;
    }
}
```

## 5.5 스프링 MVC - 컨트롤러 통합

@RequestMapping을 클래스 단위가 아니라 메서드 단위에 적용하여 컨트롤러 클래스들을 통합할 수 있다.

```java
@Controller
@RequestMapping("/springmvc/v2/members")
public class SpringMemberControllerV2 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @RequestMapping("/new-form")
    public ModelAndView newForm() {
        return new ModelAndView("new-form");
    }

    @RequestMapping("/save")
    public ModelAndView save(HttpServletRequest request, HttpServletResponse response) {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        ModelAndView mv = new ModelAndView("save-result");
        mv.addObject("member", member);
        return mv;
    }

    @RequestMapping
    public ModelAndView members(HttpServletRequest request, HttpServletResponse response) {
        List<Member> members = memberRepository.findAll();

        ModelAndView mv = new ModelAndView("members");
        mv.addObject("members", members);

        return mv;
    }
}
```

URL 조합
* 클래스 레벨 @RequestMapping("/springmvc/v2/members")
  * 메소드 레벨 @RequestMapping("/new-form") /springmvc/v2/members/new-form
  * 메소드 레벨 @RequestMapping("/save") -> /springmvc/v2/members/save
  * 메소드 레벨 @RequestMapping -> /springmvc/v2/members

## 5.6 스프링 MVC - 실용적인 방식

스프링 MVC는 개발자가 편리하도록 편의 기능을 제공한다. 

Annotation 기반 핸들러는 ModelAndView를 반환해도 되고 문자열을 반환해도 된다. 핸들러 어댑터가 반환 타입에 맞춰서 뷰 정보를 인식한다. 물론 반환하는 문자열을 다른 방식으로 인식하는 방법도 있다.

HttpRequest, HttpResponse 아규먼트들을 받을 수도 있고 안 받을 수도 있다.

```java
@Controller
@RequestMapping("/springmvc/v3/members")
public class SpringMemberControllerV3 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @GetMapping("/new-form")
    public String newForm() {
        return "new-form";
    }

    @PostMapping("/save")
    public String save(
            @RequestParam("username") String username,
            @RequestParam("age") int age,
            Model model
    ) {
        Member member = new Member(username, age);
        memberRepository.save(member);

        model.addAttribute("member", member);
        return "save-result";
    }

    @GetMapping
    public String members(Model model) {

        List<Member> members = memberRepository.findAll();

        model.addAttribute("members", members);
        ModelAndView mv = new ModelAndView("members");
        mv.addObject("members", members);

        return "members";
    }
}
```

Model 파라미터
* save(), members()를 보면 Model을 파라미터로 받는 것을 확인할 수 있다.

ViewName 문자열 반환
* 뷰의 논리 이름을 반환할 수 있다.

@RequestParam 사용
* 스프링은 HTTP 요청 파라미터를 @RequestParam으로 받을 수 있다.
* @RequestParam("username")은 request.getParameter("username")와 같은 코드라 생각하면 된다. GET 쿼리 파라미터, POST FORM방식을 모두 지원한다.

@GetMapping = @RequestMapping(value = "/new-form", method = RequestMethod.GET)
@PostMapping = @RequestMapping(value = "/new-form", method = RequestMethod.POST)

# 6 스프링 MVC - 기본 기능
## 6.1 스프링 MVC - 프로젝트 생성

Jar 패키징
* 항상 내장 서버(톰캣)을 사용하고 webapp 경로도 사용하지 않습니다.
* 내장 서버 구동에 최적화

War 패키징
* 내장, 외장 서버 구동 가능하지만 주로 외장 서버 구동 용도

### Welcompage

스프링부트 Jar 패키징을 사용하면 /resources/static/index.html을 기본 Welcome 페이지로 인식합니다. 

참조
https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.welcome-page

## 6.2 스프링 MVC - 로깅

로깅 라이브러리
* 스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리 spring-boot-starter-logging가 포함된다.
* 스프링 부트 로깅 라이브러리는 기본으로 다음 로깅 라이브러리를 사용한다.
  * SLF4J - http://www.slf4j.org
  * LOGBACK - http://logback.qos.ch
* SLF4J는 인터페이스이고 그 구현체로 Logback, Log4j, Log4j2 등이 있다. 
* 실무에서는 스프링 부트가 기본으로 제공하는 Logback를 대부분 사용한다.

로그 선언
* private Logger log = LoggerFactory.getLogger(getClass());
* private static final Logger log = LoggerFactory.getLogger(xxx.class);
* @Slf4j : 롬복 애노테이션

LogTestController
```java
@Slf4j
@RestController
public class LogTestController {
//    private final Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/log-test")
    public String logTest() {
        String name = "Spring";

        System.out.println("name = " + name);

        log.trace("trace log={}", name);
        log.debug("debug log={}", name);
        log.info("info log={}", name);
        log.warn("warn log={}", name);
        log.error("error log={}", name);

        return "ok";
    }
}
```

@RestController
* @Controller은 반환 값이 String이면 뷰 이름으로 인식한다. 그래서 뷰 이름을 기반으로 뷰를 찾고 렌더링한다.
* @RestController은 반환 값을 HTTP 메시지 바디에 바로 입력한다.
* @ResponseBody와 관련이 있는데 뒤에서 더 자세히 설명한다.

@Slf4j
* 다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자를 편리하게 log라고 사용하면 된다.
```java
private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class)
```

테스트
* 로그가 출력되는 포맷 확인
  * 시간, 로그 레벨, 프로세스 ID, 스레드명, 클래스명, 로그 메시지
* 로그 레벨 설정을 변경해서 출력 결과를 보자
  * LEVEL : TRACE > DEBUG > INFO > WARN > ERROR
  * 개발 서버 : DEBUG
  * 운영 서버 : INFO
* @Slf4j로 변경

로그 레벨 설정
* application.properties
  ```
  # 전체 로그 레벨 설정 ( 기본 info)
  logging.level.root = info
  
  # hello.springmvc 패키지와 그 하위 로그 레벨 설정
  logging.level.hello.springmvc = deug
  ```
* 개발시 DEBUG 설정하면 너무 많은 로그 출력되니 패키지를 DEBUG로 설정하여 로그를 확인하자.
  
올바른 로그 사용
* log.debug("data = " + data)
  * 로그 출력 레벨을 info로 설정해도 해당 코드에 있는 "data = " + data가 실행되어 문자 더하기 연산이 발생한다.
* log.debug("data = {}", data)
  * 로그 출력 레벨을 info로 설정하면 아무 연산이 발생하지 않는다.

로그 사용시 장점
* 클래스 정보, 스레드 정보 같은 부가 정보를 넣어 출력 모양을 조정할 수 있다.
* 로그 레벨을 조정하여 각 서버에 맞게 로그를 출력할 수 있다.
* 시스템 아웃 콘솔, 파일, 네트워크 별도의 위치에 로그를 남길 수 있다. 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
* 성능
* 
* 도 System.out보다 좋다.

더 공부할 것
* 로그에 대해서 더 자세한 내용을 slf4j, logback을 검색해보자
* 스프링 부트가 제공하는 로그 기능을 다음을 참고하자.
  https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging

## 6.3 스프링 MVC - 요청 매핑

MappingController
```java
@RestController
public class MappingController {

    private Logger log = LoggerFactory.getLogger(getClass());

    /**
     * 기본 요청
     * 둘다 허용 /hello-basic, /hello-basic/
     * HTTP 메서드 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE
     */
    @RequestMapping("/hello-basic")
    public String helloBasic() {
        log.info("helloBasic");
        return "ok";
    }

    /**
     * method 특정 HTTP 메소드 요청만 허용
     * GET, HEAD, POST, PUT, PATCH, DELETE
     */
    @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)
    public String mappingGetV1() {
        log.info("mappingGetV1");
        return "ok";
    }
}
```

@Controller
* 스프링 MVC에서 Controller 클래스
* 스프링 빈 자동 등록
* RequestMappingHandlerMapping 정보에 포함되는 기준은 @Controller, @RequestMapping이 클래스 레벨에 적용되어 있는 경우이다.
* 반환 값이 문자열인 경우 뷰 정보로 인식한다.

@RestController
* @Controller가 적용되어 있다.
* 반환 값이 문자열인 경우 HttpMessageBody에 입력된다.

@RequestMapping("/url")
* 해당 URL이 호출되면 해당 메소드가 수행된다.
* 대부분의 속성값을 배열로 제공하므로 다중 설정이 가능하다.
* "/url", "/url/" 모두 매핑된다.
* {"/url1", "/url2"} URL 다중 설정이 가능하다.
* method를 지정하지 않으면 HTTP메서드와 무관하게 매핑된다.

### HTTP 메서드 매핑 축약

```java
    /**
     * 편리한 축약 애노테이션
     *
     * @GetMapping
     * @PostMapping
     * @PutMapping
     * @DeleteMapping
     * @PatchMapping
     */
    @GetMapping(value = "/mapping-get-v2")
    public String mappingGetV2() {
        log.info("mapping-get-v2");
        return "ok";
    }
```

@GetMapping, @PostMapping, @HeadMapping@PutMapping, @DeletePaiing, @PatchMapping
* @RequestMapping(method)와 기능이 같다.

### PathVariale

@RequestMapping은 URL경로를 템플릿화 할 수 있는데 @PathVariable을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.

```java
    /**
     * PathVariable 사용
     * 변수명이 같으면 생략 가능
     *
     * @PathVariable("userId") String userId -> @PathVariable userId
     */
    @GetMapping("/mapping/{userId}")
    public String mappingPath(@PathVariable("userId") String data) {
        log.info("mappingPath userId={}", data);
        return "ok";
    }
```

```java
    /**
     * PathVariable 사용 다중
     */
    @GetMapping("/mapping/users/{userId}/orders/{orderId}")
    public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {
        log.info("mappingPath userId={}, orderId={}", userId, orderId);
        return "ok";
    }
```

### 특정 파라미터 조건 매핑

param
* 특정 파라미터가 있거나 없을 때 매핑할 수 있다.

```java
    /**
     * 파라미터로 추가 매핑
     * params="mode",
     * params="!mode"
     * params="mode=debug"
     * params="mode!=debug" (! = )
     * params = {"mode=debug","data=good"}
     */
    @GetMapping(value = "/mapping-param", params = "mode=debug")
    public String mappingParam() {
        log.info("mappingParam");
        return "ok";
    }
```

### 특정 헤더 조건 매핑

headers
* 특정 헤더, 헤더값에 따라 매핑할 수 있다.

```java
    /**
     * 특정 헤더로 추가 매핑
     * headers="mode",
     * headers="!mode"
     * headers="mode=debug"
     * headers="mode!=debug" (! = )
     */
    @GetMapping(value = "/mapping-header", headers = "mode=debug")
    public String mappingHeader() {
        log.info("mappingHeader");
        return "ok";
    }
```

### 미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume

Content-Type 헤더 클라이언트 -> 서버의 ContentType

HTTP요청의 Content-Type헤더를 기반으로 미디어 타입으로 매핑한다.
만약 맞지 않는 경우 415 상태코드(Unsupported Media Type)가 응답된다.

```java
    /**
     * Content-Type 헤더 기반 추가 매핑 Media Type
     * consumes="application/json"
     * comsumes="!application/json"
     * consumes="application/*"
     * consumes="*\/*"
     * MediaType.APPLICATION_JSON_VALUE
     */
    @PostMapping(value = "/mapping-consume", consumes = "application/json")
    public String mappingConsumes() {
        log.info("mappingConsumes");
        return "ok";
    }
```

### 미디어 타입 조건 매핑 - HTTP 요청 Accept, produce

Accept 헤더 서버 -> 클라이언트의 Content-Type

HTTP요청의 Acept헤더를 기반으로 미디어 타입으로 매핑한다. 매핑되지 않으면 HTTP 406 상태코드(Not Accepable)을 반환한다.

```java
    /**
     * Accept 헤더 기반 Media Type
     * produces="text/html"
     * produces="!text/html"
     * produces="text/*"
     * produces="*\/*"
     */
    @PostMapping(value = "/mapping-produces", produces = "text/html")
    public String mappingProduces() {
        log.info("mappingProduces");
        return "ok";
    }
```

## 6.4 스프링 MVC - 요청 매핑 - API 예시

회원 관리를 HTTP API를 만든다고 가정할 때

회원 관리 API
* 회원 목록 조회 GET /users
* 회원 등록 POST /users
* 회원 조회 GET /users/{userId}
* 회원 수정 PATCH /users/{userId}
* 회원 삭제 DELETE /users/{userId}

```java
@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {

    /**
     * GET /mapping/users
     */
    @GetMapping()
    public String user() {
        return "get users";
    }

    /**
     * POST /mapping/users
     */
    @PostMapping()
    public String addUser() {
        return "post user";
    }

    /**
     * GET /mapping/users/{userId}
     */
    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId) {
        return "get userId = " + userId;
    }

    /**
     * PATCH /mapping/users/{userId}
     */
    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId) {
        return "update userId = " + userId;
    }

    /**
     * DELETE /mapping/users/{userId}
     */
    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId) {
        return "delete userId = " + userId;
    }
}
```

## 6.5 스프링 MVC - HTTP 요청 - 기본, 헤더 조회

애노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다. 이번 시간에는 HTTP 헤더 정보를 조회하는 방법을 알아보도록 하자.

```java
@Slf4j
@RestController
public class RequestHeaderController {

    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String, String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCookie", required = false) String cookie
    ) {
        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("host={}", host);
        log.info("cookie={}", cookie);
        return "ok";
    }
}
```
```java
request=org.apache.catalina.connector.RequestFacade@6a8b8243
response=org.apache.catalina.connector.ResponseFacade@13fea042
httpMethod=GET
locale=ko_KR
headerMap={user-agent=[PostmanRuntime/7.29.0], accept=[*/*], host=[localhost:8080], accept-encoding=[gzip, deflate, br], connection=[keep-alive]}
host=localhost:8080
cookie=null
```

* HttpServletRequest
* HttpSErvletResponse
* HttpMethod : Http 메소드 정보
* Locale : Locale 정보
* @RequestHeader MultiValueMap<String, String> headerMap
  * 모든 HTTP 헤더를 MultiValueMap 타입으로 조회한다.
* @RequestHeader("host") String host
  * 특정 HTTP 헤더를 조회한다.
  * 속성
    * 필수 값 여부 : required
    * 기본 값 속성 : defaultValue
* @CookieValue(value = "myCookie", required = false) String cookie
  * 특정 쿠키를 조회한다.
  * 속성
    * 필수 값 여부 : required
    * 기본 값 속성 : defaultValue

MultiValueMap
* Map과 유사한데 하나의 키에 여러 값을 받을 수 있다.
* HttpHeader, Http쿼리파라미터에서 하나의 키에 여러 값을 받을 때 사용한다.
* keyA=value1&keyA=value2
```java
MultiValueMap<String, String> map = new LinkedMultiValueMap();
map.add("keyA", "value1");
map.add("keyA", "value2");

//["value1", "value2"]
List<String> value = map.get("keyA");
```

@Slf4j
다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자를 편리하게 log라고 사용하면 된다.
```java
private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class)
```

@Controller의 파라미터 목록
https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments

@Controller의 응답 값 목록
https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types

## 6.6 스프링 MVC - HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form

클라이언트에서 서버로 요청 데이터를 전달하는 방법은 3가지다.
1. GET - 쿼리 파라미터
   * /url?username=hello&age=20
   * URL 쿼리 파라미터에 데이터 포함
   * 주로 검색 필터, 페이징 등에서 많이 사용
2. POST - HTML FORM
   * content-type:application/x-www-form-urlencoded
   * HttpMessageBody에 쿼리 파라미터 형식으로 전달 username=hello&age=20
   * 주로 회원 가입, 상품 주문, HTML FORM 사용
3. POST, PUT, PATCH - HttpMessageBody
   * POST, PUT, PATCH
   * 데이터 형식은 주로 JSON형식, JSON, XML, TEXT 가능
   * 주로 HTTP API에서 사용

HttpServletRequest의 request.getParameter()를 사용하면 다음 두가지 요청 파라미터를 조회할 수 있다.
* GET - 쿼리 파라미터
* POST - HTML FROM 
* GET은 URL에 POST는 HttpMessageBody에 담기지만 쿼리 파라미터 형식으로 담긴다.
* 이것을 간단히 요청 파라미터(request parameter) 조회라 한다.

반환 타입이 없으면서 이렇게 응답에 값을 직접 집어넣으면, view 조회X
```java
@Slf4j
@Controller
public class RequestParamController {

    /**
     * 반환 타입이 없으면서 이렇게 응답에 값을 직접 집어넣으면, view 조회X
     */
    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        log.info("username={}, age={}", username, age);

        response.getWriter().write("ok");
    }
}
```

HttpForm 작성
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="/request-param-v1" method="post">
    username: <input type="text" name="username"/>
    age: <input type="text" name="age"/>
    <button type="submit">전송</button>
</form>
</body>
</html>
```

HttpForm을 사용해서 Post 쿼리파라미터 전송을 해도 정상 동작하는 것을 확인할 수 있다.


참고로 JAR인 경우 /resources/static 경로에, WAR인 경우 /WEB-INF/ 경로에 두어야 한다. JAR의 경우 정적 리소스도 클래스 경로에 함께 포함해야한다.

## 6.7 스프링 MVC - HTTP 요청 파라미터 - @RequestParam

@RequestParam으로 요청 파라미터를 편리하게 사용할 수 있다.

@RequestParam 사용
* 파라미터 이름으로 바인딩

@ResponseBody 추가
* View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력

@RequestParam
```java
    /**
     * @RequestParam 사용
     * - 파라미터 이름으로 바인딩
     * @ResponseBody 추가
     * - View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력
     */
    @RequestMapping("/request-param-v2")
    @ResponseBody
    public String requestParamV2(
            @RequestParam("username") String memberName,
            @RequestParam("age") int memberAge
    ) {
        log.info("username={}, age={}", memberName, memberAge);

        return "ok";
    }
```

@RequestParam("username") String memberName 
-> String memberName = request.getParameter("username");

@RequestParam 파라미터명 생략 - 변수명과 파라미터명과 같으면
```java
    /**
     * @RequestParam 사용
     * HTTP 파라미터 이름이 변수 이름과 같으면 @RequestParam(name="xx") 생략 가능
     */
    @ResponseBody
    @RequestMapping("/request-param-v3")
    public String requestParamV3(
            @RequestParam String username, @RequestParam int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

@RequestParam 생략 - String, Int 같은 기본 타입인 경우
```java
    /**
     * @RequestParam 사용
     * String, int 등의 단순 타입이면 @RequestParam 도 생략 가능
     */
    @ResponseBody
    @RequestMapping("/request-param-v4")
    public String requestParamV4(String username, int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

파라미터 필수 여부 - requestParamRequired
```java
    /**
     * @RequestParam.required 
     */
    @ResponseBody
    @RequestMapping("/request-param-required")
    public String requestParamRequired(
            @RequestParam(required = true) String username,
            @RequestParam(required = false) int age
    ) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

@RequestParam의 required 옵션으로 필수여부를 지정할 수 있다. 기본 값은 true이다.

주의
1. /request-param
   * username이 없으므로 400 예외
2. /request-param?username= 
   * 빈 문자로 통과 ""
   * 참고로 ""과 NULL은 다름
3. /request-param
   * Primitive 기본형(int) 변수에 null을 입력하는 것은 불가능
   * Wrapper 클래스 Integer 변경해야 함 
   * 또는 다음에 나오는 defaultValue 사용

기본 값 적용 - requestParamDefault
```java
    /**
     * @RequestParam - defaultValue 사용
     * <p>
     * 참고: defaultValue는 빈 문자의 경우에도 적용
     * /request-param?username=
     */
    @ResponseBody
    @RequestMapping("/request-param-default")
    public String requestParamDefault(
            @RequestParam(required = true, defaultValue = "guest") String username,
            @RequestParam(required = false, defaultValue = "-1") int age
    ) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

참고로 "/request-param?username="과 같이 빈문자열로 요청이 와도 defaultValue 적용

파라미터 Map 조회 - requestParamMap
```java
    /**
     * @RequestParam Map, MultiValueMap
     * Map(key=value)
     * MultiValueMap(key=[value1, value2, ...] ex) (key=userIds, value=[id1, id2])
     */
    @ResponseBody
    @RequestMapping("/request-param-map")
    public String requestParamDefault(@RequestParam Map<String, Object> paramMap) {
        log.info("username={}, age={}", paramMap.get("username"), paramMap.get("age"));
        return "ok";
    }
```

파라미터 값이 중복될 수 있다면 MultiValueMap을 사용하자.

## 6.8 스프링 MVC - HTTP 요청 파라미터 - @ModelAttribute

실제 개발을 하면 요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주어야 한다. 보통 다음과 같이 코드를 작성한다.
```java
@RequestParam String username;
@RequestParam int age;

HelooData data = new Hellodata();
data.setUsername(username);
data.setAge(age);
```

이 과정을 자동화해주는 @ModelAttribute를 제공한다.

HelloData
```java
@Data
public class HelloData {
    private String username;
    private int age;
}
```

롬복 @Data
* @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredARgsConstructor 를 자동으로 적용해준다.

```java
    /**
 * @ModelAttribute 사용
 * 참고: model.addAttribute(helloData) 코드도 함께 자동 적용됨, 뒤에 model을 설명할 때 자세히 설명
 */
@ResponseBody
@RequestMapping("/model-attribute-v1")
public String modelAttributeV1(@ModelAttribute HelloData helloData) {
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());
        log.info("helloData={}", helloData);

        return "ok";
        }
```

스프링 MVC는 @ModelAttribute가 있으면 다음을 실행한다.
1. HelloData 객체를 생성한다.
2. 요청 파라미터의 이름으로 HelloData 객체의 프로퍼티를 찾는다. 해당 프로퍼티의 setter을 호출해서 파라미터의 값을 입력(바인딩)한다.
3. 파라미터 이름이 username이면 setUsername() 메서드를 찾아서 호출하면서 값을 입력한다.

바인딩오류
바인딩시 BindException이 발생할 수 있다.

@ModelAttribute - 생략
```java
    /**
     * @ModelAttribute 생략 가능
     * String, int 같은 단순 타입 = @RequesteParam
     * argument resolver 로 지정해둔 타입 외 = @ModelAttribute
     */
    @ResponseBody
    @RequestMapping("/model-attribute-v2")
    public String modelAttributeV2(HelloData helloData) {
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());
        log.info("helloData={}", helloData);

        return "ok";
    }
```

@ModelAttribute는 생략할 수 있다. 그런데 @RequestParam도 생략할 수 있으므로 혼란이 발생할 수도 있다. 스프링은 다음 같은 규칙을 적용한다.
1. String, int, Integer 같은 단순 타입 -> @RequestParam
2. 일반 타입 -> @ModelAttribute
3. ArgumentResolver로 지정해둔 타입 -> 미적용

## 6.9 스프링 MVC - HTTP 요청 메시지 - 텍스트

3. POST, PUT, PATCH - HttpMessageBody
  * POST, PUT, PATCH
  * 데이터 형식은 주로 JSON형식, JSON, XML, TEXT 가능
  * 주로 HTTP API에서 사용

요청 파라미터와 다르게 HTTP메시지바디를 통해 데이터가 직접 데이터가 넘어오는 경우 @RequestParam, @ModelAtrribute를 사용할 수 없다.

HTML FORM 형식으로 전달되는 경우는 요청 파라미터로 인정된다.

HttpMessageBody의 데이터는 InputStream을 통해서 직접 읽을 수 있다.

### Http 요청 메시지 - 기본

```java
@Slf4j
@Controller
public class RequestBodyStringController {

    @PostMapping("/request-body-string-v1")
    public void requestBodyStringV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("meesageBody={}", messageBody);

        response.getWriter().write("ok");
    }
}
```

스트림은 바이트코드이다. 바이트코드를 받을 때는 항상 어떤 인코딩인지 설정을 해주어야 된다고 알고 있자.

### Http 요청 메시지 - InputStream, OutputStream

```java
    /**
     * InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회
     * OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력
     */
    @PostMapping("/request-body-string-v2")
    public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException {
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("meesageBody={}", messageBody);

        responseWriter.write(messageBody);
    }
```

스프링 MVC는 다음 파라미터를 지원한다.
* InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회
* OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력

### Http 요청 메시지 - HttpEntity

```java
    /**
     * HttpEntity: HTTP header, body 정보를 편라하게 조회
     * - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     * <p>
     * 응답에서도 HttpEntity 사용 가능
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     */
    @PostMapping("/request-body-string-v3")
    public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) throws IOException {

        String messageBody = httpEntity.getBody();
        log.info("meesageBody={}", messageBody);

        return new ResponseEntity<String>("ok", HttpStatus.OK);
    }
```

스프링 MVC는 다음 파라미터를 지원한다.
* HttpEntity : Http header, body 정보를 편리하게 조회
  * 메시지 바디 정보를 직접 조회
  * 요청 파라미터를 조회하는 기능과 관계 없음
* HttpEntity는 응답에도 사용 가능
  * 메시지 바디 정보 직접 반환
  * 헤더 정보 포함 기능
  * VIEW 조회 x

HttpEntity를 상속한 다음 객체들도 같은 기능을 제공한다.
* RequestEntity
  * HttpMethod URL 정보 추가, 요청에서 사용
* ResponseEntity
  * Http 상태코드 설정 기능 추가, 응답에서 사용
  * return new ResponseEntity<String>("Hello World", responseHeader, HttpStatus.CREATED)

### Http 요청 메시지 - @RequestBody, @ResponseBody

```java
    /**
     * @RequestBody - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     * @ResponseBody - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     */
    @PostMapping("/request-body-string-v4")
    @ResponseBody
    public String requestBodyStringV4(@RequestBody String messageBody) throws IOException {

        log.info("meesageBody={}", messageBody);

        return "ok";
    }
```

@RequestBody
* 요청 된 Http 메시지 바디 정보를 편리하게 조회할 수 있다. 헤더 정보를 조회할 때는 @RequestHeader를 사용하면 된다.

@ResponseBody
* 응답 결과를 Http 메시지 바디에 담아서 전달할 수 있다. 

요청 파라미터 vs HttpMessageBody
* 요청 파라미터를 조회하는 기능 : @RequestParam, @ModelAttribute
* Http메시지바디를 직접 조회하는 기능 : @RequestBody

## 6.10 스프링 MVC - HTTP 요청 메시지 - JSON

```java
/**
 * {"username":"hello", "age":20}
 * content-type: application/json
 */
@Slf4j
@Controller
public class RequestBodyJsonController {

    private ObjectMapper objectMapper = new ObjectMapper();

    @PostMapping("/request-body-json-v1")
    public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messageBody={}", messageBody);
        HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        response.getWriter().write("ok");
    }
}
```

HttpServletRequest를 사용해서 직접 Http메시지바디에서 데이터를 읽어와서 문자로 변환한다.

문자로 된 JSON데이터를 Jackson 라이브러리인 objectMapper를 사용해서 자바 객체로 변환한다.

InputStream -> String : StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
JSON String -> Object : objectMapper.readValue(messageBody, HelloData.class);

### HTTP 요청 메시지 - JSON - @RequestBody

```java
    /**
     * @RequestBody HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     * @ResponseBody - 모든 메서드에 @ResponseBody 적용
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     */
    @PostMapping("/request-body-json-v2")
    @ResponseBody
    public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException {

        log.info("messageBody={}", messageBody);
        HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

@RequestBody를 사용해서 요청 HttpMessageBody를 꺼내고 문자로 된 JSON 데이터를 Jackson ObjectMapper로 객체로 변환한다.

### HTTP 요청 메시지 - JSON - @RequestBody

문자로 변환하고 다시 JSON으로 변환하는 과정이 불편하다. @ModelAttribute처럼 한번에 객체로 변환할 수 없을까 ?

```java
    /**
     * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
     * HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter (content- type: application/json)
     */
    @PostMapping("/request-body-json-v3")
    @ResponseBody
    public String requestBodyJsonV3(@RequestBody HelloData helloData) {

        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

JSON의 경우 HttpMessageConverter가 ContentType:Application/JSON 이면 MappingJackson2HttpMessageConverter를 사용해서 HttpMessageBody를 객체로 Converter한다.

참고로 여기서 @RequestBody를 생략하면 @ModelAttribute를 생략하는것과 구분할 수 없기 때문에 생략할 수 없다.

@RequestBody 객체 파라미터
* @RequestBody HelloData data
* @RequestBody에 직접 만든 객체를 지정할 수 있다.

HttpEntity, @RequestBody를 사용하면 HttpMessageConverter가 HttpMessageBody를 문자나 객체로 변환해준다. HttpMessageConverter는 문자 뿐만 아니라 JSON 객체로 변환해주는데 objectMapper.readValue()를 자동으로 적용해준다고 생각하면 된다.

주입!
* HTTP 요청시에 content-type:application/json 인지 확인해야 한다. 그래야 JSON으로 인식할 수 있다.

### HTTP 요청 메시지 - JSON - HttpEntity

HttpEntity를 이용한 방법을 살펴만 보자.

```java
    @PostMapping("/request-body-json-v4")
    @ResponseBody
    public String requestBodyJsonV4(HttpEntity<HelloData> httpEntity) {
        HelloData data = httpEntity.getBody();
        log.info("username={}, age={}", data.getUsername(), data.getAge());
        return "ok";
    }
```

### HTTP 요청 메시지 - JSON - ResponseBody

```java
    /**
     * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
     * HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter (content- type: application/json)
     * @ResponseBody 적용
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter 적용 (Accept: application/json)
     */
    @ResponseBody
    @PostMapping("/request-body-json-v5")
    public HelloData requestBodyJsonV5(@RequestBody HelloData data) {
        log.info("username={}, age={}", data.getUsername(), data.getAge());
        return data;
    }
```

@ResponseBody
* 응답의 경우에도 @ResponseBody를 사용하면 해당 객체를 HttpMessageBody에 넣어줄 수 있다.

@RequestBody (contentType : application/json)
* JSON 요청 -> HttpMessageConverter -> 객체
@ResponseBody (accept : application/json)
* 객체 -> HttpMessageConverter -> JSON 응답

## 6.11 스프링 MVC - HTTP 응답 - 정적 리소스, 뷰 템플릿

스프링에서 응답 데이터를 만드는 방법은 크게 3가지다.

정적 리소스
* 웹 브라우저에 정적인 HTML, CSS, JS를 제공할 때는 정적 리소스를 사용한다.
뷰 템플릿 사용
* 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.
HTTP 메시지 사용
* HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로 HTTP 메시지 바디에 JSON같ㅇㄴ 형식으로 데이터를 실어 보낸다.

### 정적 리소스

스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공한다

/static
/public
/resources
/META-INF/resources

src/main/resources는 리소스를 보관하는 곳이고 또 클래스패스의 시작 경로이다.
따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.


src/main/resources/static
* 다음 경로에 파일이 들어가있으면 src/main/resources/static/basic/hello-form.html 웹 브라우저에서 다음과 같이 요청할 수 있따. http://localhost:8080/basic/hello-form.html

정적 리소스는 해당 파일을 변경 없이 그대로 서비스 하는 것이다.

### 뷰 템플릿

뷰 템플릿을 거쳐서 HTML이 생성되고 뷰가 응답을 만들어서 전달한다. 

스프링 부트는 기본 뷰 템플릿 경로를 제공한다.
* src/main/resources/templates

뷰 템플릿 생성
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.tyhmeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p th:text="${data}">empty</p>

</body>
</html>
```

뷰 템플릿을 호출하는 컨트롤러
```java
@Controller
public class ResponseViewCointroller {

    @RequestMapping("/response-view-v1")
    public ModelAndView responseViewV1() {
        ModelAndView mav = new ModelAndView("/response/hello")
                .addObject("data", "hello!");

        return mav;
    }

    @RequestMapping("/response-view-v2")
    public String responseViewV2(Model model) {
        model.addAttribute("data", "hello!");
        return "/response/hello";
    }

    @RequestMapping("/response/hello")
    public void responseViewV3(Model model) {
        model.addAttribute("data", "hello!");
    }
}
```

### String을 반환하는 경우 - View or Http메시지

@ResponseBody가 없으면 response/hello로 뷰 리졸버가 실행되어서 뷰를 찾고 렌더링된다. @ResponseBody가 있으면 뷰 리졸버를 실행하지 않고 HttpMessageBody에 직접 "response/hello"라는 문자열을 담는다.

Void를 반환하는 경우
* @Controller를 사용하고 HttpServletResponse, OutputStream(Writer)같은 메시지 바디를 처리하는 파라미터가 없으면 요청 URL을 참고해서 논리 뷰 이름으로 사용
* 요청 /response/hello -> template/response/hello.html
* 참고로 이 방식은 명시성이 너무 떨어져 권장하지 않는다.

Http메시지
* @ResponseBody, HttpEntity를 사용하면 뷰 템플릿을 사용하는 것이 아니라 HTTPMessageBody에 직접 응답데이터를 출력할 수 있다.

### ThymeLeaf 스프핑 부트 설정

build.gradle
```
implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
```

스프링 부트가 자동으로 ThymeleafViewResolver와 필요한 스프링 빈들을 등록한다. 그리고 다음 설정도 사용한다. 이 설정은 기본값이기 때문에 변경이 필요할 때 설정한다.

application.properties
```text
spring.thymeleaf.prefix=classpath:/template/
spring
```

Thymeleaf 관련 설정을 여기를 참조하자. Thymeleaf 검색

https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.templating

## 6.12 스프링 MVC - HTTP 응답 - HTTP API, 메시지 바디에 직접 입력

Http API를 제공하는 경우에는 데이터를 전달해야 하므로 HttpMessageBody에 JSON 타입으로 데이터를 실어서 보낸다.

참고
* HTML이나 뷰 템플릿을 사용해도 HTTP 응답 메시지 바디에 HTML 데이터가 담겨서 전달된다. 여기서 설명하는 내용은 정적 리소스나 뷰 템플릿을 거치지 않고 직접 HTTP 응답 메시지를 전달하는 경우를 말한다.

```java
@Slf4j
@Controller
public class ResponseBodyController {

    @GetMapping("/response-body-string-v1")
    public void responseBodyV1(HttpServletResponse response) throws IOException {
        response.getWriter().write("ok");
    }

    /**
     * HttpEntity, ResponseEntity(http Status 추가)
     *
     * @return
     */
    @GetMapping("/response-body-string-v2")
    public ResponseEntity<String> responseBodyV2(HttpServletResponse response) {
        return new ResponseEntity<>("ok", HttpStatus.OK);
    }

    @ResponseBody
    @GetMapping("/response-body-string-v3")
    public String responseBodyV3() {
        return "ok";
    }

    @GetMapping("/response-body-json-v1")
    public ResponseEntity<HelloData> responseBodyJsonV1() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);

        return new ResponseEntity<>(helloData, HttpStatus.OK);
    }

    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    @GetMapping("/response-body-json-v2")
    public HelloData responseBodyJsonV2() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);
        return helloData;
    }
}
```

### ResponseBodyV1

서블릿을 직접 다룰 때 처럼 HttpServletResponse객체를 통해 HttpMessageBody에 직접 "ok" 메시지를 전달한다.

### ResponseBodyV2

ResponseEntity 엔티티는 HttpEntity를 상속 받았는데 Http 메시지의 헤더, 바디 정보를 가지고 있다. ResponseEntity는 여기에 더해서 HTTP 응답 코드를 설정할 수 있다.

### ResponseBodyV3

@ResponseBody를 사용하면 View를 사용하지 않고 HTTP Message Converter를 통해서 HTTP 메시지를 직접 입력할 수 있다. ResponseEntity와 동일한 방식으로 동작한다.

### ResponseBodyJsonV1

ResponseEntity를 반환한다. HTTP Message Converter를 통해서 JSOn 형식으로 변환되어 반환된다.

### ResponseBodyJsonV2

ResponseEntity는 HTTP 응답 코드를 설정할 수 있는데 @ResponseBody를 사용하면 이런 것을 설정하기 까다롭다. @ResponseStatus(HttpStatus.OK) 애노테이션을 사용하면 응답코드를 쉽게 설정할 수 있다. 

그래도 동적으로 응답코드를 변경할 수 는 없기 때문에 동적으로 변경하기 위해선 ResponseEntity를 사용하자.

---

@RestController
* 해당 컨트롤러 전체에 @ResponseBody를 적용하는 효과가 있다. 이름 그대로 REST API(HTTP API)를 만들 때 사용하는 컨트롤이다.

## 6.13 스프링 MVC - HTTP Message Converter

뷰 템플릿으로 HTML을 생성해서 응답하는게 아니라 HTTP API처럼 JSON 데이터를 HTTP MessageBody에 직접 읽거나 쓰는 경우 HttpMessageConverter를 사용하면 편리하다. 

![img_1](https://user-images.githubusercontent.com/79847020/159222839-1a61b96f-3394-4560-8117-241b690d895c.png)

@ResponseBody를 사용
* HTTP Body에 문자 내용 직접 반환
* viewResolver 대신 HttpMessageConverter가 동작
* 기본 문자 처리 : StringHttpMessageConverter
* 기본 객체 처리 : MappingJackson2HttpMessageConverter
* Byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음.

참고로 응답의 경우 클라이언트 Http Accpet헤더와 서버의 컨트롤러 반환 타입 정보 등을 조합해서 HttpMessageConverter가 선택된다. 

스프링 MVC는 다음 경우에 HTTPMessageConverter를 적용한다.
* HTTP 요청 : @RequestBody, HttpEntity(RequestEntity)
* HTTP 응답 : @REsponseBody, HttpEntity(ResponseEntity)

HttpMessageConverter 인터페이스
```java
public interface HttpMessageConverter<T> {
    boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);

    boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);

    List<MediaType> getSupportedMediaTypes();

    T read(Class<? extends T> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;

    void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;
}
```

HttpMessageConverter은 HTTP 요청, HTTP 응답 둘 다 사용된다. 그리고 요청이든 응답이든 HttpMessageBody에 데이터가 있으면 ContentType 헤더에 타입을 지정해야 한다.

스프링 부트 기본 HttpMessageConverter
1. 0 - ByteArrayHttpMessageConveter
2. 1 - StringHttpMessageConverter
3. 2 - MappingJackson2HttpMessageConverter

스프링 부트는 다양한 메시지 컨버터를 제공하는데 대상 클래스 타입과 미디어 타입 둘을 체크해서 사용여부를 결정한다. 

ByteArrayHttpMessageConverter
* 클래스 타입 : byte[], 미디어타입 : */*
* 요청 예) @ReqeustBody byte[] data;
* 응답 예) @ResponseBody return byte[]; 응답 미디어 타입 application/octet-stream
StringHttpMessageConverter 
* 클래스 타입 : String, 미디어타입 : */*
* 요청 예) @RequestBody String data;
* 응답 예) @ResponseBody return String; 응답 미디어 타입 : text/plain
MappingJackson2HttpMessageConverter
* 클래스 타입 : 객체 또는 HashMap, 미디어타입 : application/json
* 요청 예) @RequestBody HelloData data; 
* 응답 예) @ResponseBody return hellodata; 응답 미디어 타입 : applicationJson

StringHttpMessageConverter ( JSON -> String )
```java
content-type : application/json

@RequestMapping
void hello(@RequestBody String data) {}
```

MappingJacksong2HttpMessageConverter ( JSON -> HelloData )
```java
content-type : application/json

@RequestMapping
void hello(@RequestBody HelloData data) {}
```

? -> 컨버터 찾을 수 없다.
```java
content-type : text/html

@RequestMapping
void hello(@RequestBody helloData data) {}
```

HTTP 요청 데이터 읽기
* HTTP 요청이 오고 컨트롤러에서 @RequestBody, HttpEntity 파라미터를 사용한다.
* 메시지 컨버터가 메시지를 읽을 수 있는지 없는지 확인하기 위해 canRead()를 호출한다.
  * 대상 클래스 타입을 지원하는가
  * HTTP 요청의 Content-Type을 미디어타입을 지원하는가?
* canRead() 조건을 만족하면 read()를 호출해서 객체 생성하고 반환한다.

HTTP 응답 데이터 쓰기
* 컨트롤러에서 @REsponseBody, HttpEntity로 값이 반환된다.
* 메시지 컨버터가 메시지를 쓸 수 있는지 없는지 확인하기 위해 canWrite()를 호출한다.
  * 대상 클래스 타입을 지원하는가
  * HTTP 요청의 Acept 미디어 타입을 지원하는가??
* canWrite() 조건을 만족하면 write()를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.

READ : 메시지 -> 객체
WRITE : 객체 -> 메시지


## 6.14 스프링 MVC - 요청 매핑 핸들러 어댑터 구조

HTTP 메시지 컨버터는 스프링 MVC 어디에서 사용되는 것일까 ?

![img_2](https://user-images.githubusercontent.com/79847020/159222859-42481285-15b9-4a25-9f15-924bd91f3ee9.png)

모든 비밀은 애노테이션 기반의 컨트롤러 @RequestMapping을 처리하는 핸들러 어댑터인 RequestMappingHandlerAdapter에 있다.

![img_3](https://user-images.githubusercontent.com/79847020/159222873-a39b1f98-32c6-4285-b1f6-8ec12264357e.png)

애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있다. HttpServletRequest, Model 객체 뿐만 아니라 @RequsetParam, @ModelATtribute 같은 애노테이션 그리고 @RequestBody, HttpEntity 같은 HttpMessage를 처리하는 부분까지 유연함을 보여주었다. 이렇게 파라미터를 유연하게 처리할 수 있는 이유는 바로 ArgumentResolver 덕분이다.

애노테이션 기반 컨트롤러를 처리하는 RequestMappingHandlerAdapter는 바로 이 ArgumentResolver를 호출해서 컨트롤러가 필요로 하는 다양한 파라미터의 값을 생성한다. 파라미터가 준비되면 컨트롤러를 호출하면서 값을 넘겨준다.

스프링은 30개자 넘는 ArgumentResolver를 기본으로 제공한다. 

https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments

정확히는 HandlerMethodArgumentResolver인데 ArgumnetResolver라 부른다.

HandlerMethodArgumentResolver
```java
public interface HandlerMethodArgumentResolver {

	boolean supportsParameter(MethodParameter parameter);

	@Nullable
	Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;

}
```

동작방식
* ArgumentResolver의 supportsParameter()를 호출해서 해당 파라미터를 지원하는지 체크하고 지원하면 resolverArgument()를 호출해서 실제 객체를 생성한다. 이 객체가 컨트롤러 메소드 파라미터로 넘어가는 것이다. 

ReturnValueHandler
* HanlderMethodReturnValueHandler를 줄여서 ReturnValueHandler라 부른다. ArgumentResolver와 비슷한데 응답 값을 변환하고 처리한다.
* 컨트롤러에서 String으로 뷰 이름을 반환해도 동작하는 이유가 ReturnValueHandler 때문이다.

스프링은 10여개의 ReturnValueHandler를 지원한다.
* ModelAndView, @ResponseBody, HttpEntity, String

https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types

Http 메시지 컨버터 위치

![img_4](https://user-images.githubusercontent.com/79847020/159222879-685e63b8-f2c0-4059-ace8-2c6af9eacca6.png)

HTTP 메시지 컨버터를 사용하는 @RequestBody도 컨트롤러가 필요로 하는 파라미터의 값에 사용된다. @ResponseBody의 경우도 컨트롤러의 반환 값을 이용한다.

요청의 경우 @RequestBody를 처리하는 ArgumentResolver가 있고 HttpEntity를 처리하는 ArgumentResolver가 있다. ArgumentResolver들이 HttpMessageConverter를 사용해서 필요한 객체를 생성하는 것이다.

응답의 경우 @ResponseBody를 HttpEntity를 처리하는 ReturnValueResolver가 있다. 여기에서 HttpMessageConverter를 호출해서 응답 결과를 사용한다.

스프링 MVC는 @RequestBody, @ResponseBody가 있으면 RequestResponseBodyMethodProcessor(ArgumentResolver) HttpEntity가 있으면 HttpEntityProcessor(ArgumentResolver)를 사용한다.

확장
* 스프링은 다음을 모두 인터페이스로 제공한다. 따라서 필요하면 언제든지 기능을 확장할 수 있다.
* HandlerMethodArgumentResolver
* HandlerMethodReturnValueHandler
* HttpMessageConverter

스피링이 필요한 대부분의 기능을 제공하기 때문에 확장할일이 많지는 않다. 기능 확장은 WebMvcConfigurer를 상속 받아서 스프링 빈으로 등록하면 된다. 실제 자주 사용하지는 않지만 실제 기능 확장이 필요할 때 WebMvcConfigurer를 검색하자.

WebMVcConfigurer 확장
```java
@Bean
public WebMvcConfigurer webMvcConfigurer() {
    return new WebMVcConfigrer() {
        @Override
        public void addArgumentResolver(List<HandlerMethodArgumentResolver> resolvers){
            //...
        }
    }
}
```

## 6.15 스프링 MVC - 정리






