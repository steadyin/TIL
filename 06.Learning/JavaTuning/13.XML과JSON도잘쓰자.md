# XML과 JSON도 잘쓰자

요즘 자바로 개발을 할 때 각종 설정 파일과 DB 쿼리를 XML에서 관리하는 것은 기본이고 테이터를 XML 및 JSON 타입으로 주고 받는 시스템도 늘어나고 있다. 하지만 XML이나 JSON을 쓸 경우 시스템의 성능이 안 좋아질 수도 있다. 필요에 따라 써야 할 곳에서는 쓰는 것이 좋지만 꼭 그럴 필요가 없는 곳까지 맹목적으로 쓰는 것은 좋지 않다.

개발 중인 애플리케이션은 실시간으로 XML처리를 한다. 로컬에서 관련 코드를 수행할 때는 느리다는 생각을 하지 못했지만 서버에서 여러 사용자가 사용할 때는 느리다는 이야기가 많다. 

# 자바에서 사용하는 XML 파서의 종류는

XML은 eXtensible Markup Language의 약자이다. XML의 가장 큰 장점은 누구나 데이터의 구조를 정의하고 그 정의된 구조를 공유함으로서 일관된 데이터 전송 및 처리를 할 수 있다는 것이다. 이러한 특성 때문에 데이터를 파싱해야 한다. 요즘 대부분의 프로젝트에서는 XMl을 사용하므로 간단히 파서에는 어떤 종류가 있는 각 파서의 특징은 무엇인지 확인해보자.

마크업(Markup Language)란 태그 기반의 텍스트로 된 언어를 의마한다. 이 태그 안에 필요한 데이터를 추가함으로서 데이터를 전달하거나 보여주는 것이 주 목적이다. 가장 유명한 마크업 언어로는 여러분들이 매일 접하는 HTML이 있다. 

자바에서는 XML을 파싱하기 위해서 JAXP를 제공한다. JAXP는 SAX, DOM, XSLT에서 사용하는 기본 API를 제공한다. 그렇기 때문에 JAXP 기반의 API를 쓴다면 파서를 제공하는 벤더에 종속되지 않을 수 있다. 참고로 약어의 의미는 다음과 같다.

|약어|의미|패키지|
|---|---|---|
|JAXP|Java API for XML Processing|javax.xml.parsers|
|SAX|Simple API for XML|org.xml.sax|
|DOM|Document Object Model|org.w3c.dom|
|XSLT|Xml Stylesheet Language for Transformations|javax.xml.transform|

![image](https://user-images.githubusercontent.com/79847020/146626707-42ee73a4-87d8-4893-84c3-286d2b97aaef.png)

![image](https://user-images.githubusercontent.com/79847020/146626711-1edc2d11-3baa-4f64-81f4-7b30794dc54d.png)

JAXP의 javax.xml.parsers 패키지는 SAX와 DOM에서 사용하는 SAXParser Factory와 DocumentBuilderFactory를 제공한다. 이 파서들은 각각 XML-DEV그룹과 W3C에서 정의하였다. 그래서 관련 패키지가 자바의 표준 API에 포함되어 있다. 

SAX는 순차적 방식으로 XML을 처리한다. 반면 DOM은 모든 XML을 읽어서 트리를 만든 후 XML을 처리하는 방식이다. 다시 말하면 SAX는 각 XML의 노드를 읽는 대로 처리하기 때문에 메모리에 부담이 DOM에 비해서 많지 않다. 하지만 DOM은 모든 XML을 메모리에 올려서 작업하기 때문에 메모리에 부담이 가게 된다. 그림을 통해서 이해하는 것이 빠를 테니 먼저 SAX의 처리 방식을 보자.

SAX는 Content 핸들러, Error 핸들러, DTD 핸들러, Entity 리졸버를 통해서 순차적인 이벤트를 처리한다. 이미 읽은 데이터의 구조를 수정하거나 삭제하기 어렵다. 반면, DOM은 모든 XML의 내용을 읽은 이후에 처리한다. 읽은 XML을 통하여 노드를 추가, 수정, 삭제 하기 쉬운 구조로 되어있다. XSLT는 SAX, DOM, InputStream을 통해서 들어온 데이터를 원하는 형태의 화면으로 구성하는 작업을 수행한다. XML이 화면에서 보기 쉬운 데이터가 되도록 처리하는 것이라고 생각하면 된다.

지금까지 알아본 세가지 XML 파서 중 서버단 프로그램에서 사용하기 적합한 파서는 SAX와 DOM이다. 먼저 SAX와 DOM 파서에 대해서 간단히 알아보고 두 파서의 성능을 비교해보자.

# SAX 파서는 어떻게 사용할까 ?

SAX 파서는 앞서 이야기한대로 순차적으로 처리하는 이벤트 기반의 모델이다. DOM 보다는 손이 많이 간다. 모든 이벤트를 다 처리할 필요는 없지만 원하는 데이터를 만들려면 데이터를 어떻게 처리할지 결정해서 구현해야 하기 때문이다. 기본적으로 제공하는 SAX API는 무엇이 있는지 알아보자.

* SAXParserFactory : 파싱을 하는 파서 객체를 생성하기 위한 추상 클래스이다.
* SAXParser : 여러 종류의 parse() 메서드를 제공하기 위한 추상 클래스이다. 이 클래스의 parse() 메서드를 호출하면 파싱을 실시한다.
* DefaultHandler : 아래에 있는 ContentHandler, ErrorHandler, DTDHandler, EntityResover를 구현한 클래스이다. 상황에 따라 XML을 처리하려면 이 클래스를 구현하면 된다.
* ContentHandler : XML의 태그의 내용을 읽기 위한 메서드를 정의한 인터페이스다. startDocument, endDocument, startElement, endElement 메서드가 정의되어 있다.
* ErrorHandler : 에러를 처리하는 메서드가 정의되어 있는 인터페이스이다.
* DTDHandler : 기본 DTD 관련 이벤트를 식별하기 위한 인터페이스이다.
* EntityResover : URI를 통한 식별을 하기 위한 인터페이스이다.

```JAVA
public class ParseSAX extends DefaultHandler {
    public HashMap<String, Integer> elementMap = new HashMap<String, Integer>();
    private StringBuffer returnData = new StringBuffer();

    public ParseSAX() {
    }

    public void startDocument() {
        returnData.append("### Start Document !!!\n");
    }

    public void endDocument() {
        returnData.append("### End Document !!!\n");
        setNodeCountData();
    }

    public void startElement(String uri, String local, String nodeName,
			Attributes attrs) throws SAXException {
        addNode(nodeName);
    }

    public void addNode(String nodeName) {
        if (!elementMap.containsKey(nodeName)) {
            elementMap.put(nodeName, 1);
        } else {
            elementMap.put(nodeName, elementMap.get(nodeName) + 1);
        }
    }

    public void setNodeCountData() {
        Set<String> keySet = elementMap.keySet();
        Object[] keyArray = keySet.toArray();
        Arrays.sort(keyArray);
        for (Object tempKey : keyArray) {
            returnData.append("Element=").append(tempKey).append(" Count=")
		.append(elementMap.get(tempKey.toString())).append("\n");
        }
    }

    public String getData() {
        return returnData.toString();
    }

    public void print(String data) {
        returnData.append(data).append("<BR>");
    }
}
```
startDocument()와 endDocument() 메서드는 각각 XML 문서가 시작할 때와 끝날 때 오직 한 번씩만 수행된다.

addNode() 메서드에서는 HashMap에 해당 엘리먼트가 있는지를 확인한 후, 엘리먼트 개수를 추가하는 작업을 수행한다. setNodeCount()에서는 각 엘리먼트당 개수 정보를 returnData라는 StringBuffer에 담는다. 이 코드를 실행하는 JMH 소스는 다음과 같다.

```JAVA
@State(Scope.Thread)
@BenchmarkMode({ Mode.AverageTime })
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class XMLParser {
	
    @GenerateMicroBenchmark
    public void withSAXParse100() throws Exception {
        ParseSAX handler = new ParseSAX();
        SAXParserFactory factory = SAXParserFactory.newInstance();
        SAXParser saxParser = factory.newSAXParser();
        saxParser.parse("dummy100.xml", handler );
    }
	
    @GenerateMicroBenchmark
    public void withSAXParse1000() throws Exception {
        ParseSAX handler = new ParseSAX();
        SAXParserFactory factory = SAXParserFactory.newInstance();
        SAXParser saxParser = factory.newSAXParser();
        saxParser.parse("dummy1000.xml", handler );
    }
}
```

먼저 ParseSAX라는 클래스를 DefaultHandler의 상속을 받아서 SAX로 XML을 처리할 수 있도록 했따. 이 클래스의 parseSAX() 메서드를 호출하면 XML을 읽어서 파싱을 수행한다. 가장 먼저 handler 객체를 정의한 후 SAXParserFactory의 newInstance() 메서드를 호출하여 factory 객체를 만든다. 이 객체를 통하여 SAXParser의 객체인 saxParser를 생성한다. 그 다음엔 saxParser의 parse()메서드에 파일 객체 및 handler 객체를 사용하여 파싱을 수행한다. 그 다음엔 saxParser의 parse() 메서드에 파일 객체 및 handler 객체를 사용하여 파싱을 수행한다. 

System.out.println(handler.getData());

파싱할 XML은 다음과 같이 간단한 XML 파일이다.

```JAVA
<DataStart>
  <Product name='prod1'><Price>1</Price></Product>
  <Product name='prod2'><Price>2</Price></Product>
...
</DataStart>
```

실행 결과는 다음과 같다

|대상|평균 응답 시간|
|---|---|
|SAX 100|847|
|SAX 1000|3,925|

데이터가 100개 일 경우에는 847마이크로초, 1000개일 경우에는 3.9 ms 정도가 소요되는 것을 볼 수 있다. 데이터의 크기가 10배라고 할지라도 반드시 10배의 시간이 소요되지는 않는다.

# DOM 파서는 어떻게 사용할까 ?

DOM 파서는 SAX 파서와 다르게 XML을 트리 형태의 데이터로 먼저 만든 후, 그 데이터를 가공하는 방식을 사용한다. DOM에서의 주요 클래스를 알아보면 다음과 같다.

* DocumentBuilderFactory : 파싱을 하는 파서 객체를 생성하기 위한 추상 클래스
* DocumentBuilder : 여러 종류의 parse() 메서드를 제공하는 추상 클래스, 이 클래스의 parse() 메서드를 호출하면 파싱을 실시한다.
* Document : SAX와 다르게 파싱을 처리한 결과를 저장하는 클래스
* Node : XML과 관련된 모든 데이터의 상위 인터페이스. 단일 노드에 대한 정보를 포함하고 있다.

```JAVA

public class ParseDOM {
    HashMap<String, Integer> elementMap = new HashMap<String, Integer>();
    private StringBuffer returnData = new StringBuffer();

    public void parseDOM(String XMLName) {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        try {
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(XMLName);
            Node rootNode = document.getChildNodes().item(0);
            addNode(rootNode.getNodeName());
            readNodes(rootNode);
            setNodeCountData();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

SAX와 크게 다른 점은 따로 핸들러를 지정하지 않고 파싱한 데이터를 Document 클래스의 객체에 담아서 리턴해준다는 것이다. 읽어온 노드를 어떻게 처리하는지 보자.

```JAVA
    public void readNodes(Node node) {
        NodeList childs = node.getChildNodes();
        int childCount = childs.getLength();
        for (int loop = 0; loop < childCount; loop++) {
            Node tempNode = childs.item(loop);
            if (tempNode.hasChildNodes()) {
                readNodes(tempNode);  // 재귀 호출
            }
            String nodeName = tempNode.getNodeName();
            if (!nodeName.equals("#comment") && !nodeName.equals("#text")) {
                addNode(nodeName);
            }
        }
    }
    
    public void addNode(String nodeName) {
        if (!elementMap.containsKey(nodeName)) {
            elementMap.put(nodeName, 1);
        } else {
            elementMap.put(nodeName, elementMap.get(nodeName) + 1);
        }
    }
    
    public void setNodeCountData() {
        Set<String> keySet = elementMap.keySet();
        Object[] keyArray = keySet.toArray();
        Arrays.sort(keyArray);
        for (Object tempKey : keyArray) {
            returnData.append("Element=").append(tempKey).append(" Count=")
			.append(elementMap.get(tempKey.toString())).append("<BR>");
        }
    }
    
    public String getData() {
        return returnData.toString();
    }    
```    

가장 처음에 있는 메소드를 보면 노드의 getChildNodes() 메서드를 호출하여 자식 노드의 목록을 얻는다. 자식 노드의 개수만큼 반복하여 자식 노드의 정보를 읽는다. 만약 그 자식 노드도 자식이 있다면 이 메서드를 호출해야 하므로 재귀적으로 처리하였다. 나머지 3개의 메서드(addNode(), setNodeCountData(),getData())는 SAX의 예와 동일하므로 추가적인 설명은 하지 않겠다. 이 코드를 실행하는 JMH 메서드는 XMLParser 클래스에 다음의 내용을 추가하면 된다.

```JAVA
@GenerateMicroBenchmark
public void withDOMParse100() {
    ParseDOM pd=new ParseDOM();
    pd.parseDOM("dummy100.xml");
}
	
@GenerateMicroBenchmark
public void withDOMParse1000() {
    ParseDOM pd=new ParseDOM();
    pd.parseDOM("dummy1000.xml");
}
```

만약 JMH로 실행하지 않고 결과를 확인하고 싶다면 다음과 같이 출력문을 추가하면 된다.

System.out.println(pd.getData());

소스는 매우 간단하고 SAX와 거의 동일하다. 수행 결과를 보자.

|대상|평균 응답 시간|
|---|---|
|DOM 100|1,395|
|DOM 1,000|7,129|

DOM 파서를 사용하면 보는 것과 같이 100건일 경우 1.4ms, 1000건일 경우 7.1ms가 소요된다. 그러면 SAX 파서와 DOM 파서의 성능을 한 자리에 놓고 같이 비교해보자.

|대상|응답시간|대상|응답시간|
|---|---|---|---|
|SAX 100|647|DOM 100|1,395|
|SAX 1,000|3,925|DOM 1,000|7,129|

데이터의 크기가 커지면 커질수록 두 파서간의 차이가 커지는 것을 볼 수 있다. 하지만 이 예제에서 처리한 XML의 구조는 단순한다. 복잡하고 큰 파일일수록 SAX와 DOM 파서에게 처리하는 시간은 더 늘어날 것이다. 그리고 처리하는 데 소요되는 대부분의 시간은 parse() 메서드에서 처리하는 CPU 시간이다. 즉 대기 시간은 없지만 XML을 처리하는 과정에서 CPU에 순차적으로 많은 부하가 발생한다는 것이다. 

그리고 순수하게 파서에게 사용하는 메모리 사용량만 측정해 보면 다음과 같다.

||SAX 파서 사용시|DOM 파서 사용시|
|---|---|---|
|메모리 사용량|56MB|292MB|

SAX 파서는 XML 파일 크기의 거의 두 배를 메모리를, DOM 파서는 거의 열배의 메모리를 사용한다. 즉 XML 파일의 크기가 클 때 DOM 파서를 사용한다면 OutOfMemoryError가 빈번히 일어날 확률이 매우 크다.

# XML 파서가 문제가 된 사례

어떤 사이트는 여러 지역에 WAS가 분리되어 있는데 특정 지역의 WAS에서 힙 덤프가 1분에 한 번씩 발생하고 있었다. 힙 덤프를 분석하자 다음과 같은 결과가 나왔다.

힙 덤프는 현재 JVM의 힙 메모리에 점유하고 있는 객체에 대한 정보를 파일로 생성해 놓은 것이다. OOM가 발생했을 때 자동으로 힙 덤프를 저장하도록 하려면 "-XX:+HeapDumpOnOutOfMemoryError" 옵션을 추가하면 되며, 힙 덤프가 발생하는 경로를 지정하고자 할 경우에는 "-XX:HeapDumpPath=/app/tomcat/dump/"와 같이 저장하는 경로를 추가하면 된다. 이 힙 덤프에 대한 자세한 설명은 필자의 자바 개발자와 시스템 운영자를 위한 트러블 슈팅 이야기를 참고하기 바란다.

|메모리 사용량|비율|클래스|
|---|---|---|
|737,306,056|68%|java.lang.ref.Finalizaer|
|327,686,792|30%|java.lang.UnixProcess|

UnixProcess와 관련된 부분은 WAS에서 기본적으로 점유하고 사용하는 메모리이다. 문제는 Finallizer 클래스에서 잡고 있는 메모리였다. 이 클래스는 GC를 하기 위해서 호출되는데 추적을 해서 들어가보니 하나의 XML을 처리하기 위한 Handler 클래스에서 700MB 정보의 메모리를 점유하고 있었다.

이러한 현상이 발생하는 이유를 천천히 짚어보자. 해당 사이트는 XML로 문서를 주고 받는다. XML을 파싱하기 위해서 파서가 있어야 하는데 대부분의 WAS에는 파서가 내장되어 있다. 



