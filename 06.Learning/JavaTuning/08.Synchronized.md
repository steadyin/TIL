# Synchronized는 제대로 알고 써야 한다.

웹 기반 시스템을 개발할 때 여러분들이 스레드를 컨트롤할 일은 별로 없다. 스레드를 직접 건드리면 서비스의 안전성이 떨어질 수도 있으니 자제하는 것이 좋다. 우리가 개발하는 WAS는 여러 개의 스레드가 동작하도록 되어 있다. 그래서 synchronized를 자주 사용한다. 하지만 synchronized를 쓴다고 무조건 안정적인 것은 아니면, 성능에 영향을 미치는 부분도 있다. 스레드가 어떻게 작동되는지 간단하게 알아보고 무엇을 조심해야 하는지 확인해보자.

# 자바에서 스레드는 어떻게 사용하나 ?

## 프로세스와 스레드

클래스를 하나 수행시키거나 WAS를 기동하면 서버에 자바 프로세스가 하나 생성된다. 하나의 프로세스에는 여러 개의 스레드가 생성된다. 단일 스레드가 생성되어 종료될 수도 있고 여러 개의 스레드가 생성되어 수행될 수도 있다. 그러므로 프로세스와 스레드의 관계는 1대다 관계라고 보면된다. 프로세스와 스레드는 왜 이러한 관계가 만들어질까? 스레드는 다른 말로 LightWeight Process(LWP)라고도 한다. 즉 가벼운 프로세스이고 프로세스에서 만들어 사용하고 있는 메모리를 공유한다. 그래서 별개의 프로세스가 하나씩 뜨는 것보다는 성능이나 자원 사용에 있어서 많은 도움이 된다.

## Thread 클래스 상속과 Runnable 인터페이스 구현

스레드의 구현은 Thread 클래스를 상속 받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다. 기본적으로 Thread 클래스는 Runnable 인터페이스를 구현한 것이기 때문에 어느 것을 사용해도 거의 차이가 없다. 

Runnable 인터페이스를 구현한 클래스이다.

```JAVA
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
      System.out.println("This is RunnableImpl.");
    }
}
```

Thread 클래스를 확장한 경우다.

```JAVA
public class ThreadExtends extends Thread{
  
    public void run() {
      System.out.println("This is ThreadExtends.");
    }
}
```

이 클래스들을 어떻게 실행해야 할까? Thread 클래스를 상속받은 경우에는 start() 메서드를 호출하면 된다. 하지만 Runnable 인터페이스를 구현한 경우에는 Thread 클래스의 Runnable 인터페이스를 매개변수로 받는 생성자를 사용해서 Thread 클래스를 만든 후 start() 메서드를 호출해야 한다. 그렇게 하지 않고 그냥 run() 메서드를 호출하면 새로운 스레드가 생성되지 않는다. (Runnalbe의 run() 메서드를 구현하고 Thread 객체의 start() 메서드로 스레드 실행)

```JAVA
public class RunThreads {
    public static void main(String[] args) {
      RunnableImpl ri = new RunnableImpl();
      ThreadExtends te = new ThreadExtends();
      new Thread(ri).start();
      te.start();
    }
}
```

실행을 하면 결과 값이 고정되지 않는다는 것을 확인할 수 있다. 스레드를 호출하면서 우선순위를 따로 지정하지 않았으므로 Thread 클래스를 상속 다은 결과가 먼저 나올 수 있고 Runnable 인터페이스를 구현한 결과가 먼저 나올 수도 있다.

## sleep(), wait(), join() 메서드

현재 진행 중인 스레드를 대기하도록 하기 위해서는 sleep(), wait(), join() 세 가지 메서드를 사용하는 방법이 있다. wait() 메서드는 모든 클래스의 부모 클래스인 Object 클래스에 선언되어 있으므로 어떤 클래스에서도 사용할 수 있다. 이 세 가지 메서드는 모두 예외를 던지도록 되어 있어 사용할 때는 반드시 예외 처리를 해주어야 한다.

sleep() 메서드는 명시된 시간 만큼 해당 스레드를 대기시킨다. 이 메서드는 다음과 같은 두 가지 방법으로 매개변수를 지정해서 사용한다. 

* sleep(long millis) : 명시된 ms 만큼 해당 스레드가 대기한다. static 메서드이기 때문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.
* sleep(long millis, int nanos) : 명시된 ms + 명시된 나노 시간 만큼 해당 스레드가 대기한다.

wait() 메서드도 명시된 시간만큼 스레드를 대기시킨다. sleep() 메서드와 다른 점은 매개변수인데 아무런 매개변수를 지정하지 않으면 notify() 메서드 혹은 notifyAll() 메서드가 호출될 때까지 대기한다. wait() 메서드가 대기하는 시간을 설정하는 방법은 sleep() 메서드와 동일하다.

join() 메서드는 명시된 시간만큼 해당 스레드가 죽기를 기다린다. 만약 아무런 매개변수를 지정하지 않으면 죽을 때 까지 계속 대기한다.

## interrupt(), notify(), notifyAll() 메서드

앞서 명시한 세 개의 메서드를 모두 멈출 수 있는 유일한 메서드는 interrupt() 메서드다. interrupt() 메서드가 호출되면 중지된 스레드에는 InterruptedException이 발생한다. 제대로 수행되었는지 확인하려면 interrupted() 메서드를 호출하거나 isInterrupted() 메서드를 호출하면 된다. 두 방법의 차이는 interrupted() 메서드는 스레드의 상태를 변경시키지만 isInterrupted() 메서드는 단지 스레드의 상태만을 리턴한다는 점이다.

추가로 isAlive() 메서드라는 것이 있는데 이는 해당 스레드가 살아있는지 확인하는 메서드다. 스레드가 살아있다면 true를 그렇지 않으면 false를 리턴한다.






