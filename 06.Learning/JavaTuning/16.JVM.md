# JVM은 도대체 어떻게 구동될까?

전 세계에 있는 대부분의 시스템들은 지속적으로 변경된다. 다시 말해서 주기적으로 수정하고 배포(release)하는 작업을 반복한다. 만약 여러분들이 웹 기반 시스템을 배포할 때 그냥 재시작만 한다면, 배포 직후 시스템 사용자들은 엄청나게 느린 응답 시간과 함께 시스템에 대한 많은 불만을 갖게 될 수도 있다. 즉 Warming up이 필요한데 왜 이러한 작업이 필요한지에 대해서 알아보자.

* HotSpot VM의 구조
* JIT 옵티마이저
* JVM의 구동 절차
* JVM의 종료 절차
* 클래스 로딩의 절차
* 예외 처리의 절차

이 장의 주요 내용은 Charlie Hunt와 Binu John가 집필한 Java Performance 라는 책의 내용의 일부와 IBM 및 Oracle 홈페이지에서 발췌하여 정리한 것이다.

OpenJDK 문서 중에는 HotSpot 관련 용어들을 풀이한 페이지(http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html)을 제공하고 있다.

# HotSpot VM은 어떻게 구성되어 있을까 ?

자바 관련 문서들을 읽다 보면, HotSpot VM이라는 용어를 종종 접했을 것이다. HotSpot VM에 대해서 살펴보기 전에 HotSpot이 무엇인지 알아보자.(http://en.wikipedia.org/wiki/HotSpot)

HotSpot이라는 단어는 일반적으로 붙여 사용하지 않고, Hot Spot이라는 숙어로 사용된다. 단어를 직역하면 '뜨거운 지점'이라고 번역할 수 있지만, '분쟁 지역', '활기 넘치는 곳'이라는 의미로 사용된다. 이 단어는 자바에서 HotSpot이라는 한 단어로 쓰이며, 정확한 명칭은 'Java HotSpot Performance Engine'이다. 그런데, 왜 이렇게 이름을 지었을까?

자바를 만든 Sun에서는 자바의 성능을 개선하기 위해서 Just In Time(JIT) 컴파일러를 만들었고, 이름을 HotSPot으로 지었다. 여기서 JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다. 분석된 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다.

이 HotSpot은 자바 1.3 버전부터 기본 VM으로 사용되어 왔기 때문에, 지금 운영하고 있는 대부분의 시스템들은 모두 HotSpot 기반의 VM이라고 생각하면 된다. HotSpot VM은 세 가지 주요 컴포넌트로 되어 있다.

* VM(Virtual Machine) 런타임
* JIT(Just In Time) 컴파일러
* 메모리 관리자

HotSpot VM은 높은 성능과 확장성을 제공한다. 일례로 JIT 컴파일러는 자바 애플리케이션이 수행되는 상황을 보고 동적으로 최적화를 수행한다.

```
JIT는 우리나라말로 하면 '적절한 시간'이라는 의미다. JIT를 사용한다는 것은 '언제나 자바 메서드가 호출되면 바이트 코드를 컴파일하고
실행 가능한 네이티브 코드로 변환한다'는 의미다. 하지만, 매번 JIT로 컴파일을 하면 성능 저하가 심하므로, 최적화 단계를 거치게 된다.
```

HotSpot VM의 아키텍처 그림을 보자.

![image](https://user-images.githubusercontent.com/79847020/147840712-6023eccb-3c3f-4a40-8087-c013049754b5.png)

이 그림에서 보듯이 레고처럼 'HotSpot VM 런타임'에 'GC 방식'과 'JIT 컴파일러'를 끼워 맞춰 사용할 수 있다. 이를 위해서 'VM 런타임'은 JIT 컴파일러용 API와 가비지 컬렉터용 API를 제공한다. 그리고, JVM을 시작하는 런처와 스레드 관리, JNI 등도 VM 런타임 등에서 제공한다.

# JIT Optimizer라는 게 도대체 뭘까?

HotSpot VM JIT 컴파일러에 대해서 자세히 이야기하기 전에 Client 버전과 Server 버전으로 나뉜다는 것을 기억해 두자.

컴파일이라는 작업은 상위 레벨의 언어로 만들어진 코드를 기계에 의존적인 코드로 변환하는 것을 말한다. 전통적으로 컴파일러인 C나 C++를 예를 들어 생각해 보자. C의 경우 먼저 소스코드에서 object 파일을 만들고, 이 object로 수행 가능한 라이브러리로 만든다. 이 작업은 애플리케이션이 수행되는 것과 비교해서 지속, 반복적으로 수행되지 않고 한 번만 수행된다. 그런데, 자바는 javac라는 컴파일러를 사용한다. 이 컴파일러는 소스코드를 바이트 코드로 된 class라는 파일로 변환해 준다. 그렇기 때문에 JVM은 항상 바이트 코드로 시작하여, 동적으로 기계에 의존적인 코드로 변환한다.

JIT는 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시간적 여유가 많지 않다. 그러므로, 모든 코드는 초기에 인터프리터에 의해서 시작되고, 해당 코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다. HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두 개의 카운터가 존재한다.

* 수행 카운터(invocation counter) : 메서드를 시작할 때마다 증가
* 백에지 카운터(backedge counter) : 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가

여기서 백에지 카운터는 메서드가 루프가 존재하는지를 확인할 때 사용되며, 수행 카운터 보다 컴파일 우선순위가 높다. 이 카운터들이 인터프리터에 의해서 증가될 때마다 그 값들이 한계치에 도달했는지를 확인하고 도달했을 경우 인터프리터는 컴파일을 요청한다. 여기서 수행 카운터에서 사용하는 한계치는 CompileThreshold이며 백에지 카운터에서 사용하는 한계치는 다음의 공식으로 계산한다.

CompileTrhreshold * OnStackReplacePercentage / 100

```
참고로 이 두 개 값들은 JVM이 시작할 때 지정 가능하며 다음과 같이 시작 옵션으로 지정할 수 있다. 

XX:CompileThreshold=35000 XX:OnStackReplacePercentage=80

이렇게 지정하면 메서드가 3만 5천 번 호출되었을 때 JIT에서 컴파일을 하며 백에지 카운터가 35000 * 80 / 100 = 28000 되었을 때 컴파일된다.
```

컴파일이 요청되면 컴파일 대상 목록의 큐에 쌓이고 하나 이상의 컴파일러 스레드가 이 큐를 모니터링 한다. 만약 컴파일러 스레드가 바쁘지 않을 때는 큐에서 대상을 빼내서 컴파일을 시작한다. 보통 인터프리터는 컴파일이 종료되기를 기다리지 않는 대신, 수행 카운터를 리셋하고 인터프리터에서 메서드 수행을 계속 한다. 
