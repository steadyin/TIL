![image](https://github.com/user-attachments/assets/6a5bf541-508a-48b9-90f8-f054039bb18e)# Nginx

프로젝트에서 엔진엑스를 사용했는데 엔진엑스란 무엇인가요?

웹서버, 리버스 프록시, 로드 밸런서, , http 캐시로도 쓰일 수 있는 소프트웨어

요청에 응답하기 위해 이벤트 기반 구조를 채택했고 덕분에 웹 서버 분야에서 1등을 하고 있습니다.

# 이벤트 기반 구조 ?

# Apache vs NginX

1995 vs 2002




1995 유닉스 기반 최초의 웹서버 NCSA HTTPd가 있었습니다.

버그가 너무 많아서 새롭게 개발한게 Apach 서버 입니다.

새로운 클라이언트의 요청이 들어올 때 마다 프로세스를 생성합니다.

![image](https://github.com/user-attachments/assets/42e36fca-897f-4bee-9316-93983fe3e0d6)

이는 UNIX 계열 OS가 네트워크 커넥션을 형성하는 모델을 그대로 채택한 것입니다.

프로세스를 만드는 것은 비교적 비용이 드는 작업이므로 요청이 들어오기 전에 프로세스를 미리 만들어두는 PREFORK 방식을 사용했습니다.

새로운 클라이언트로부터 요청이 오면 미리 만들어둔 프로세스를 할당하는 구조였습니다. 만들어둔 프로세스를 모두 할당했다면 새로운 프로세스를 만들었습니다.

이는 개발하기 간단하다는 장점과 확장성에 좋았습니다. 개발자는 다양한 모듈을 만들어서 서버에 빠르게 적용할 수 있었습니다.

![image](https://github.com/user-attachments/assets/c6378f44-c806-408b-af7d-3c4922c6136f)

이런식으로 아파치 서버는 동적 컨텐츠를 처리할 수 있었습니다. 그리고 확장성이 좋다는 장점 때문에 요청을 받고 응답을 처리하는 과정을 하나의 서버에서 처리하기 좋았습니다.

1999년 부터는 인터넷이 활성화 되면서 서버가 처리해야하는 트래픽이 증가하고 있었습니다. 서버에 동시에 많은 커넥션이 발생했을 때 커넥션을 더이상 생성하지 못하는 문제가 발생했습니다.

이를 C10K문제라고 했습니다. Connection 10000 Problem 의 약어입니다. 

동시에 연결된 커넥션 수는 초당 요청 처리수와는 다릅니다. 초당 요청 처리수는 말그대로 서버가 초당 얼마나 빨리 요청을 처리할 수 있는지를 나타내는 지표입니다.

그리고 동시에 연결된 커넥션 수란 요청을 처리하기 위해 서버가 한 시점에 얼마나 많은 클라이언트와 커넥션을 형성하고 있는지를 나타냅니다. 한 클라이언트는 하나의 커넥션을 통해서 여러 요청을 보낼 수 있습니다.

그리고 커넥션은 긴 시간 동안 유지될 수 있기 때문에 두 지표는 같다고 볼 수 없습니다. 커넥션이 길게 유지되는 이뉴는 커넥션을 형성하는데 여러 절차들이 있기 때문입니다. 그래서 이 시기는 각 요청마다 매번 커넥션을 만들기엔 비효율적이고 속도도 느렸죠. 

그래서 이미 만들어진 커넥션이 있다면 그것을 재활용하자는 생각을 합니다. http 프로토콜을 보면 header의 종류중에 keep-alive가 있죠. 이 header에 적힌 시간만큼 클라이언트와 서버는 한번 형성한 커넥션을 계속 유지해요. 

그런데 클라이언트 수가 많아지면 그만큼 동시에 연결되어 있는 커넥션 수는 더더욱 많아지겠죠. 동시 커넥션 수가 10000 단위를 넘어가는 순간 서버는 더 이상 커넥션을 형성하지 못하는 상황입니다. 

그런데 C10K 문제에서 하드웨어는 이미 그 어느 때보다 성능 발전이 빠른 상황이였습니다. 웹 페이지의 컨텐츠 용량을 고려했을 때 하드웨어 문제라고 보기는 어려웠습니다. 

아파치 서버는 구조상 커넥션이 형성될 때 마다 할당 된 프로세스가 늘어나기 때문에 이는 곧 메모리 부족현상으로 이어지게 됩니다. 설상가상으로 아파치 서버의 여러가지 모듈을 쉽게 추가할 수 있는 확장성은 프로세스가 차지하는 리소스의 양을 늘리게 되었습니다.

그리고 많은 커넥션이 들어오게되면 CPU는 프로세스 바꿔가며 동작해야했습니다. 이를 컨텍스트 스위칭을 많이한다는 의미이고 이는 비용이 증가한다는 의미입니다. 

2004년 아파치 서버 개발자들은 새로운 구조로 보완합니다. 그게 NGINX입니다.

초창기에 NGINX는 아파치 서버과 함께 사용하기 위해 만들어졌습니다. 웹 서버 이긴 하지만 아파치 서버를 완전히 대체할 목적은 아니였습니다. 아파치가 가진 구조적 한계를 Nginx를 사용함으로서 극복하려고 했습니다.

![image](https://github.com/user-attachments/assets/92391294-88c7-4c48-bcd6-cbabb822acf6)

아파치 서버 앞에 엔진엑스 서버를 두어서 아파치가 감당해야 했던 커넥션을 엔진엑스가 대신해서 유지할 수 있었습니다. 구조적으로 동시 커넥션을 유지하지 못하는 아파치 서버의 부하를 수많은 동시 커넥션을 Nginx가 대신해서 유지할 수 있어요.

이게 포인트예요.

구조적으로 동시 커넥션을 많이 유지 못 하는 아파치 서버의 부하를 Nginx를 이용해 크게 줄일 수가 있죠. 그리고 Nginx는 그 자체로 웹 서버예요. 그래서 정적 파일에 대한 요청은 스스로 처리할 수 있죠.

웹 서버 역할의 Nginx는 클라이언트로부터 동적 파일 요청을 받았을 때만 뒤에 있는 서버와 커넥션을 형성해요. 아파치 서버의 리소스를 커넥션 유지에 쓰지 않고, 개발자가 원하는 로직 처리에 쓰도록 도와주는 거죠.

그렇다면 Nginx는 어떤 구조로 되어있길래 그 많은 동시 커넥션을 유지할 수 있을까요?

비결은 만들어지는 프로세스의 수에 있습니다. Nginx의 구조를 한 번 살펴보면 가장 먼저 마스터 프로세스라는 것을 볼 수 있어요.

설정 파일을 읽고, 설정에 맞게 워커프로세스를 생성하는 프로세스죠.

이 워커 프로세스가 실제로 일을 하는 녀석인데요. 워커 프로세스가 만들어질 때 각자 지정된 listen 소켓을 배정받아요.

그리고 그 소켓에 새로운 클라이언트로부터 요청이 들어오면 커넥션을 형성하고 그 요청을 처리합니다. 그러고 나면 그 커넥션은 정해진 keep alive 시간만큼 유지되겠죠.

그런데 커넥션이 형성되었다고 해서 워커 프로세스가 해당 커넥션 하나만 한정적으로 담당하진 않아요. 형성된 커넥션에서 아무런 요청이 없으면 새로운 커넥션을 형성하거나 이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리합니다.

Nginx에서는 이런 커넥션 형성, 커넥션 제거 그리고 새로운 요청을 처리하는 것을 이벤트라고 불러요.

![image](https://github.com/user-attachments/assets/2d920b07-c812-4cc5-9b52-4ebf4fd5c019)

그리고 그 이벤트들은 OS 커널이 큐 형식으로 워커 프로세스에게 전달해줍니다. 이 이벤트는 큐에 담긴 상태에서 워커 프로세스가 처리할 때까지 비동기 방식으로 대기해요.

![image](https://github.com/user-attachments/assets/e9cea7a7-1577-412c-acb7-4f3514f1bf36)

그리고 워커 프로세스는 하나의 스레드로 이벤트를 꺼내서 처리해 나가죠. 저 네모 칸들이 큐인데요. 안에 보면 커넥션을 생성하거나 요청을 처리하는 이벤트로 채워져 있는 것을 볼 수 있어요.

이러면 워커 프로세스가 쉬지 않고 계속해서 일을 한다는 장점이 있어요. 아파치 서버의 구조와 비교했을 때, 요청이 없다면 방치되던 프로세스보다

서버 자원을 훨씬 효율적으로 쓰는 셈이죠. 그런데 여기서 이런 질문이 생길 수 있을 것 같아요.

# 만약 이 요청 중 하나가 시간이 오래 걸리는 작업이면 어떻게 할까요?

예를 들어 Disk에 읽고 써야 하는 작업을 해야 한다면, 그 뒤에 있는 이벤트는 요청을 처리하는 긴 시간 동안 블로킹 되겠죠.

![image](https://github.com/user-attachments/assets/4e4ab461-03eb-4aa0-a02c-f921c278e622)

Nginx는 이런 상황을 방지하기 위해 그렇게 시간이 오래 걸리는 작업을 따로 수행하는 스레드 풀을 만들어 놔요. 

그리고 워커 프로세스는 지금 처리할 요청이 시간이 오래 걸릴 것 같다 싶으면 해당 스레드 풀에 그 이벤트를 위임하고, 큐 안에 있는 다른 이벤트를 처리하러 가죠.

이런 워커 프로세스는 보통 CPU의 코어 수 만큼 생성해요. 이러면 코어가 담당하는 프로세스를 바꾸는 횟수를 대폭 줄일 수 있어요.

![image](https://github.com/user-attachments/assets/6ed61c65-8fc5-46c1-ad4c-b725c30fbc94)

CPU가 굳이 그런 부가적인 일을 하지 않아도 되는 거죠. 다시 말해 CPU의 컨텍스트 스위칭 사용을 줄이는 거예요. 

이게 바로 Nginx가 채택한 event-driven model, 즉 이벤트 기반 구조이고, 아파치 서버와 가장 큰 차이점입니다.

Nginx의 이런 구조는 단점도 있어요. 개발자가 기능 추가를 시도했다가 돌아가고 있는 워커 프로세스를 종료하게 되는 상황이 생길 수 있는 건데요. 그러면 해당 워커 프로세스가 관리하고 있던 커넥션과 관련된 요청을 더 이상 처리할 수 없게 되는 문제가 발생하죠.

그래서 Nginx는 개발자가 직접 모듈을 만들기가 까다로워요.

하지만 단점에 비해 장점이 너무나도 명확했어요. 

![image](https://github.com/user-attachments/assets/e7f484a4-b5e4-4eed-a0e2-b01ad074db8b)

수많은 동시 커넥션을 빠르게 처리하는데, 프로세스를 적게 만들다 보니 가볍기까지 했죠.

그리고 프로세스를 적게 만드는 이 구조는 Nginx의 설정을 동적으로 바꾸는 것을 가능하게 해요. 개발자가 설정 파일을 변경하고 Nginx에 해당 설정을 적용하면 마스터 프로세스는 그 설정에 맞는 워커 프로세스를 따로 생성해요.

그리고 기존에 있던 워커 프로세스가 더 이상 커넥션을 형성하지 않도록 하죠. 

시간이 지나 기존 워커 프로세스가 담당하던 이벤트 처리가 모두 끝나면, 해당 프로세스를 종료합니다.

![image](https://github.com/user-attachments/assets/4d15f950-6bdc-4bae-8e31-117ba364141e)

그런데 이런 동적 설정 변경을 언제 쓸까요? 아주 대표적인 경우로, Nginx가 여러 동시 커넥션을 관리하는 도중에 뒷단에 서버가 추가되는 상황이 있어요.

그땐 Nginx가 로드 밸런서의 역할을 담당하게 되는 건데요. 로드밸런서는 요청을 여러 서버로 분산하는 작업을 수행하죠. Nginx 뒤에 새로운 서버를 추가해야 하는데,

Nginx는 수많은 동시 커넥션을 담당하고 있다면 설정을 바꾸기 위해 Nginx를 종료하기는 좀 어려워요.

그런데 동적으로 설정을 변경할 수 있다면 어떨까요? 동시 커넥션을 유지한 채, 그리고 기존 요청을 계속해서 처리하면서 뒷단에 서버를 추가 할 수 있죠.

Nginx는 이런 설정 변경을 초당 수십번을 해도 무리 없이 커넥션을 관리하고 요청을 서버에 전달해요.

![image](https://github.com/user-attachments/assets/63efe826-4378-4fe1-b879-823f49ffe675)

이벤트 기반 구조라서 가능한 방식이죠.

그런데 신기하게도 Nginx가 처음 출시되었을 때는 사용자가 그리 많지 않았어요. 2007년까지만 해도 아파치 서버는 여전히 웹 서버 1위 자리를
차지하고 있었고 Nginx는 순위권에도 없었죠.

그런데 2008년부터 아파치 서버는 점점 점유율을 잃기 시작하고 Nginx는 빠른 속도로 치고 올라오기 시작해요.

도대체 2008년에 무슨 일이 있었던 걸까요? 2008년에는 스마트폰이 인터넷 환경을 바꾸기 시작했어요.

스마트폰은 사람들이 인터넷을 더 많이 사용하게 된 계기이기도 했지만, 동시 커넥션을 훨씬 더 많이 생성하는 계기이기도 했거든요.

사람들은 자신의 최애 아이돌의 무대 영상이라든지, 짝사랑이 방금 올린 사진을 알림으로 받고 싶어 했어요.

다양한 정보를 실시간으로 제공받고 싶어하는거죠. 그리고 웹에 담기는 콘텐츠가 다양해지고, 그 용량이 커지면서 브라우저도 리소스를 빨리 가져오기 위해 여러 TCP 커넥션을 동시에 형성하기 시작했어요.

그리고 각각의 커넥션은 모두 keep alive 설정으로 유지되었고요. 결국 동시 커넥션 문제를 처리해야 할 서버가 날이 갈수록 많아졌죠.

회사들은 빠르게 Nginx라는 대체재에 눈을 돌리기 시작했어요.

특히 Nginx는 대규모 사이트를 운영하고 있는 큰 회사들이 좋아할 만한 솔루션이죠. 덕분에 Nginx가 인터넷 트래픽에 관여하는 비중은 멈추지 않고 계속 증가해요.

아파치 진영도 시대에 맞게 MPM이라는 모듈을 추가해서 성능을 개선해요. MPM이란 Multi Processing Modules의 약자로, 아파치 서버를 어떤 방식으로 운영할지 선택할 수 있게끔 해주는 모듈이었어요.

안정성이나 하위호환이 필요하다면 기존의 prefork 방식을 사용하고, 성능 향상을 원한다면, 워커라고 불리는 스레드를 만들어서 워커가 요청을 처리하도록 했죠.

![image](https://github.com/user-attachments/assets/db4584f3-25a7-4561-9fab-f0e80c2aa70a)

워커 어디서 많이 들어봤죠? 개발자들은 이렇게 구조적인 한계를 그나마 줄이기 위한 시도를 계속해서 해요.

그런데 성능 테스트 결과를 보면 아직까지 동시커넥션 관련 지표에선 Nginx가 아파치를 크게 앞서요. 이 지표는 동시 커넥션 수당 메모리 사용률인데요. Nginx는 동시커넥션이 많아져도 메모리 사용률이 낮고 일정하게 나오는 방면 아파치 서버는 굉장히 많이 사용하죠.

동시커넥션 수가 많아졌을 때 처리하는 초당 요청 수는 오히려 Nginx가 훨씬 많고 아파치는 낮다는걸 볼 수 있어요.

최소 두 배 이상 차이 나는 것을 볼 수 있죠. 이는 Nginx가 커넥션 관리를 얼마나 잘하는지 알려줘요.

사실 저희가 지금 동시 커넥션이라는 포인트에만 집중해서 그렇지 아파치가 아직 Nginx와 세계 1~2위를 다투는 데에는 다 그만한 이유가 있어요.

아파치 서버 이전의 웹 서버는 버그가 굉장히 많았다는 사실 기억하시나요? 버그 수정을 계기로 시작된 게 아파치 서버이기에, 그리고 지금까지 오랜 기간 업데이트를 계속해왔기 때문에 서버 자체가 다양한 OS에서 안정적이라는 장점이 있어요.

Nginx는 그렇지 않아서, 윈도우에서 제대로 된 성능을 발휘하지 못하거든요. 그리고 모듈을 추가해서 그 기능을 확장하기 쉽다는 장점 기억나시나요? 아파치 서버로 만들어진 오래된 서비스라고 해도 현재 잘 돌아가 있고 모듈로 기능을 계속 추가할 수 있다면 굳이 다른 서버로 옮길 이유가 없겠죠.

그리고 모듈의 종류는 아파치 서버가 Nginx보다 훨씬 많아요. 

자 제가 이렇게 구구절절하게 설명을 한 건 각 웹 서버가 어떠한 이유로 나왔는지를 알면, 그 서버를 왜 선택해야 하는지 알 수 있다는 것을 말하고 싶었어요. 이 두 서버가 탄생한 이유를 보면 사실 대립 관계가 아니거든요.

애초에 만들어진 목적 자체가 달랐던 거죠. 아파치 서버가 서버계의 1등을 할 때에는 안정성과 확장성이 무엇보다 중요했고, Nginx가 치고 올라올 때는 동시 커넥션 문제가 너무나도 중요한 상황이었어요.

그럼 이제 마지막으로 2021년에 와서 과연 우리는 Nginx를 어떻게 사용해야 하는지를 간단하게 키워드 중심으로 살펴볼게요.

이 테코톡을 보고 관심있는 키워드를 학습해보시면 정말 좋을 것 같아요.

앞서 저희는 Nginx의 웹 서버로서의 기능, 그리고 로드 밸런서로서의 기능을 살펴봤어요. 그런데 Nginx는 동시 커넥션을 여러 개 유지할 수 있고, 그 자체가 가볍다는 장점을 살려서 이 외에도 다양한 방법으로 웹 서버 가속기 역할을 해요.

![image](https://github.com/user-attachments/assets/6d485ddb-1388-4ce5-b02a-8b706b531587)

먼저 Nginx는 SSL 터미네이션을 수행할 수 있어요. SSL 터미네이션이란 Nginx가 클라이언트와는 https 통신을 하고, 서버와는 http 통신을 하는 것을 말해요. 이 구조를 만들어서 서버가 복호화 과정을 감당하지 않도록 할 수 있어요. 비즈니스 로직 처리에 리소스를 사용할 수 있도록 부하를 줄여줘요.

보통 Nginx와 서버는 같은 네트워크 안에 있는 경우가 많기 때문에, 이 둘은 http 통신을 해도 보안적인 위험이 비교적 적어요. 

두 번째로, Nginx는 http 프로토콜을 사용하여 전달하는 콘텐츠를 캐싱할 수 있어요. 앞서 SSL 터미네이션을 설명할 때는 서버와 Nginx가
같은 네트워크에 있다고 말했는데, 캐싱을 하는 경우는 Nginx를 반대로 클라이언트 쪽에 가깝게 배치해요. 

그리고 한 번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달하죠.

Nginx는 이 외에도 HSTS, CORS 처리, TCP/UDP 커넥션 부하 분산, 그리고 HTTP/2 지원 등 정말 많은 방식으로 서버를 지원해요.

그러니 Nginx를 아키텍처에 도입하신다면, 어떤 기능이 있는지 알아보고, 적극적으로 적용하시면 좋을것 같아요.

오늘 발표한 내용은 다음과 같은 곳에서 더 구체적으로 확인할 수 있고, 제가 설명하지 않은 부분도 더 볼 수 있습니다. 

마지막으로 꿀 정보 하나 제공하고 마무리하도록 하겠습니다. 

현업에서 일하는 개발자들이 모은 Nginx 설정 템플릿인데요. 일반적인 상황에서 이 템플릿을 이용하면 Nginx를  더욱 빠르게, 편하게, 강력하게 사용할 수 있어요. 물론 제대로 된 아키텍처를 구축하려고 한다면 템플릿 말고 Nginx를 실제로 튜닝해서 써야겠죠. 이상 발표 마치도록 할게요. 


출처 :

https://www.nginx.com 블로그
http://www.kegel.com/c10k.html
https://www.aosabook.org/en/nginx.html
Apache HTTP Server 공식 홈페이지
https://hackmag.com/devops/nginx-interview


Chatgpt

-------------------------------------------------------
아키텍처:
NGINX는 비동기 이벤트 기반 아키텍처를 채택하여 하나의 워커가 수천 개의 연결을 효율적으로 처리할 수 있습니다. 반면 Apache는 전통적으로 멀티 프로세스나 멀티 스레드 방식으로 요청을 처리하며, 동기적 처리 구조가 많습니다. 다만 Apache는 Event MPM을 통해 비동기 처리가 가능하게 최적화할 수 있습니다.

동시 연결 처리:
NGINX는 이벤트 루프 방식을 사용하여 연결 수가 많아도 성능이 크게 저하되지 않으며, 적은 자원으로도 많은 동시 연결을 유지할 수 있습니다. Apache는 Event MPM을 사용할 경우 동시성 처리 성능이 크게 개선되지만, 일반적인 MPM 방식으로는 동시 연결 처리에서 NGINX보다 불리합니다.

정적 vs 동적 콘텐츠 처리:
NGINX는 정적 콘텐츠 제공에 매우 최적화되어 있고, 리버스 프록시 및 로드 밸런서 역할을 많이 합니다. 동적 콘텐츠는 외부 프로그램(FastCGI 등)을 통해 처리합니다. 반면 Apache는 다양한 모듈을 통해 PHP, Python, Perl 등의 동적 콘텐츠를 직접 처리할 수 있어 유연성이 뛰어납니다.

메모리 및 CPU 사용량:
NGINX는 가벼운 메모리 및 CPU 사용으로 많은 트래픽을 처리할 수 있는 반면, Apache는 요청 수가 많아지면 상대적으로 더 많은 자원을 소모하게 됩니다.

설정 파일 구조:
NGINX는 nginx.conf와 같이 구조가 간결하고 설정이 직관적입니다. 반면 Apache는 httpd.conf, .htaccess 등을 통해 다양한 설정이 가능하지만, 더 복잡할 수 있습니다.

유연성 및 모듈 지원:
Apache는 매우 많은 모듈을 동적으로 로딩할 수 있어 다양한 기능을 확장할 수 있습니다. 반면 NGINX는 확장 모듈을 정적으로 컴파일해야 하므로 유연성 측면에서는 Apache보다 제한적입니다.

요약
NGINX는 정적 콘텐츠 제공, 리버스 프록시, 로드 밸런싱에 최적화되어 있으며, 적은 자원으로도 대규모 동시 연결 처리에 뛰어난 성능을 발휘합니다. 복잡하지 않은 설정으로 빠르게 구성할 수 있어 성능 최적화가 중요한 경우 적합합니다.

Apache는 다양한 모듈을 통한 유연성과 동적 콘텐츠 처리에서 강점을 가지며, 보다 광범위한 기능을 제공합니다. 특히, .htaccess 파일을 통해 디렉토리별 설정이 가능하다는 점에서 유연한 설정 관리가 필요한 상황에서 유리합니다.

-------------------------------------------------------

아파치와 nginx의 동시 접속하는 대량 커넥션을 처리하는 방법에 대해서 비교해서 알려줘

Apache와 NGINX가 대량의 동시 접속을 처리하는 방식은 그들의 아키텍처 차이에 기반합니다. 두 서버는 각각 다른 방식을 사용하여 다수의 클라이언트 요청을 처리하며, 동시 접속에 대한 성능 차이를 결정하는 중요한 요소입니다.

1. Apache의 동시 접속 처리 방식
Apache는 주로 멀티 프로세스(MPM: Multi-Processing Module) 또는 멀티 스레드 기반의 동시 접속 처리 방식을 사용합니다. Apache에는 여러 MPM 모듈이 있으며, 이들 중에서 가장 일반적으로 사용되는 두 가지는 Prefork MPM과 Worker MPM입니다. 최근에는 비동기 방식인 Event MPM도 도입되었습니다.

(1) Prefork MPM (멀티 프로세스 기반, 동기적)
동작 방식: 각 클라이언트 요청마다 별도의 프로세스를 할당합니다. 하나의 프로세스가 하나의 클라이언트 요청을 처리하는 동기적 방식입니다.
특징: 안정성은 높지만, 각 요청을 처리하기 위해 새로운 프로세스를 생성하거나 기존 프로세스 풀에서 할당해야 하므로, 메모리 사용량과 CPU 오버헤드가 큽니다.
한계점: 대규모 트래픽을 처리하기에는 부적합합니다. 각 프로세스가 많은 메모리를 차지하기 때문에, 동시 접속 수가 증가하면 서버 리소스가 부족해질 수 있습니다.

(2) Worker MPM (멀티 스레드 기반, 동기적)
동작 방식: 하나의 프로세스가 여러 스레드를 생성하고, 각 스레드가 클라이언트 요청을 처리합니다. 요청을 처리하는 동안 스레드는 블로킹됩니다.
특징: Prefork MPM보다 더 적은 자원으로 많은 동시 접속을 처리할 수 있지만, 여전히 요청당 하나의 스레드를 할당하고, 그 스레드가 요청 처리 중에는 다른 작업을 처리할 수 없으므로 성능에 제한이 있습니다.

(3) Event MPM (비동기, 이벤트 기반)
동작 방식: NGINX와 유사하게 비동기적, 이벤트 기반 방식으로 동작합니다. Keep-alive 요청을 처리할 때 스레드가 대기 상태에 머물지 않고, I/O 작업이 완료되면 스레드가 재사용됩니다.
특징: 더 많은 동시 접속을 효율적으로 처리할 수 있으며, 블로킹 없이 여러 연결을 유지할 수 있습니다. 이 방식은 특히 장시간 연결(예: 웹소켓)이나 HTTP Keep-alive에서 성능 향상을 제공합니다.
장점: Apache의 동시 처리 성능을 크게 향상시키며, NGINX와 같은 비동기적 처리 방식을 도입하여 대규모 트래픽에서의 처리 능력이 강화됩니다.

2. NGINX의 동시 접속 처리 방식
NGINX는 비동기적, 이벤트 기반 아키텍처로 설계되어 있습니다. 기본적으로 NGINX는 각 워커 프로세스가 다수의 클라이언트 요청을 비동기적으로 처리할 수 있습니다. 이 방식은 대량의 동시 접속에 특히 강력한 성능을 발휘합니다.

(1) 이벤트 기반, 비동기 처리
동작 방식: NGINX는 이벤트 루프와 비동기 I/O를 사용하여 요청을 처리합니다. 즉, 클라이언트로부터 요청이 들어오면 하나의 워커 프로세스가 비동기적으로 여러 요청을 동시에 처리합니다.
특징: 워커 프로세스는 비동기적으로 I/O 작업을 처리하여, 대기 시간 동안 다른 요청을 처리할 수 있습니다. 이는 CPU와 메모리 사용량을 줄이고, 하나의 워커 프로세스가 수천 개의 연결을 동시에 처리할 수 있게 합니다.
장점: 워커 프로세스가 각 요청의 모든 단계를 동기적으로 처리하지 않기 때문에, 대기 시간이 길거나 I/O 바운드인 요청을 처리할 때도 성능이 크게 저하되지 않습니다.

(2) 고정된 워커 프로세스 수
동작 방식: NGINX는 고정된 수의 워커 프로세스만을 실행합니다. 워커 프로세스의 수는 서버의 CPU 코어 수에 맞게 설정되며, 각 워커는 비동기적으로 수천 개의 요청을 처리할 수 있습니다.
특징: 워커 수를 CPU 코어에 맞추어 효율적으로 배분하며, 각 워커가 독립적으로 비동기 처리를 수행하므로 메모리와 CPU 자원을 효율적으로 사용합니다.
장점: 워커의 수를 늘리지 않고도 수천 개의 동시 접속을 처리할 수 있어, 대규모 트래픽을 처리할 때도 성능 저하가 거의 발생하지 않습니다.

(3) 저메모리 사용량
동작 방식: NGINX는 고정된 워커 프로세스와 비동기 I/O를 사용하여 메모리 사용량을 매우 낮게 유지합니다.
장점: 대규모의 동시 접속을 처리할 때에도 메모리 오버헤드가 거의 발생하지 않으며, 메모리 사용량이 늘어나는 Apache와 비교해 대규모 트래픽 처리에 유리합니다.

3. Apache와 NGINX의 동시 접속 처리 방식 비교
항목	Apache (Prefork/Worker/Event)	NGINX
아키텍처	멀티 프로세스/멀티 스레드 기반(동기 및 비동기 혼합)	비동기, 이벤트 기반
동시 연결 처리	Prefork와 Worker는 동기적, Event MPM은 비동기적 처리	비동기적, 이벤트 기반으로 다수의 연결을 한 번에 처리 가능
리소스 사용	동기적 처리 방식의 경우, 메모리 및 CPU 사용량이 큼	고정된 워커 프로세스로 메모리 및 CPU 사용량이 적음
블로킹 여부	동기적 MPM의 경우 요청마다 블로킹됨	비동기적 처리로 요청 대기 시간이 거의 없음
성능	Event MPM이 NGINX와 유사한 성능 제공하지만, 일반적으로 NGINX보다 성능이 낮음	대규모 트래픽 및 동시 접속 처리에서 뛰어난 성능 발휘
Keep-alive 처리	Event MPM에서 비동기 처리로 Keep-alive 연결 가능	매우 효율적, Keep-alive 연결을 비동기적으로 처리
적용 예	작은 규모의 사이트나 복잡한 동적 콘텐츠 처리에 적합	대규모 트래픽 처리, 고성능 리버스 프록시 및 정적 콘텐츠 제공에 최적

4. 결론
Apache는 전통적으로 멀티 프로세스/멀티 스레드 방식으로 동시 연결을 처리하며, 각각의 요청이 처리되는 동안 프로세스나 스레드가 블로킹됩니다. Event MPM을 사용하면 Apache도 비동기 처리 방식을 제공하지만, 여전히 Apache의 설계상 동시 연결 처리에서는 NGINX에 비해 비효율적일 수 있습니다.

NGINX는 비동기적 이벤트 기반 아키텍처 덕분에 대규모 동시 연결을 효율적으로 처리할 수 있으며, 메모리 및 CPU 사용량이 매우 적습니다. 특히 정적 콘텐츠 제공, 리버스 프록시, 로드 밸런싱 등의 작업에서 NGINX는 Apache보다 뛰어난 성능을 발휘합니다.

따라서, 대규모 트래픽 처리와 동시 접속 성능이 중요한 경우 NGINX가 더 적합하며, 동적 콘텐츠 처리와 모듈 확장성이 중요한 경우 Apache가 유리할 수 있습니다.


