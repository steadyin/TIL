Json Web Token에 대해서 배워볼게요. 일단 Json Web Token이 뭐냐면 JSON 객체로 안전하게 어떤 정보를 전송하기 위한 방식이에요. 이 정보는 디지털 서명이 되어 있으므로 신뢰할 수 있다는 거예요. 서명의 용도로 쓴대요. JWT는 HMAC알고리즘 또는 RSA를 사용을 한데요. ECDSA는 뭔지 모르셔도 됩니다. 
HMAC으로 쓸 때랑 RSA로 쓸 때의 방식이 조금 다르단 말이에요. 거기에 대해서 조금 이따가 한번 이해를 해볼게요. 그리고 JWT를 암호화하여 어떤 암호화 메시지를 보낼 수도 있지만 이 Json Web Token의 핵심은 서명된 Token에 중점을 둔다는 거예요. 
내가 만든 이 Json Web Token이 내가 쓴 게 맞아라는 서명의 용도로 사용을 하는 거예요. 그 서명된 토크는 그 안에 어떠한 정보가 있는데 클레임(요구 사항, 정보), 정보의 무결성을 확인할 수 있게 해줘요.

JSON Web Token는 언제 사용합니까? 이거는 이 문서를 읽어보는 것보다 실제로 우리가 사용을 하면서 이야기를 한번 해볼게요. 구조를 한번 볼 건데 한번 보면 X Y Z로 구성되요. 

![image](https://user-images.githubusercontent.com/79847020/145714773-2827ebcd-46b1-48a4-8e30-2b1d11690cdf.png)

X - 헤더
Y - 페이로드
Z - 시그니처(서명)

X이 부분을 헤더라고 하고요. Y 페이로드라고 합니다. Z 서명으로 이루어져있습니다. 

### 헤더

헤더는 일반적으로 JWT인 토큰 유형과 HMAC SHA256 또는 RSA와 같이 사용 중인 서명 알고리즘의 두 부분으로 구성된다.

```JSON
{
  "alg": "HS256",
  "typ": "JWT"
}
```

alg 알고리즘은 "HS256"을 사용하고 typ 타입은 JWT 이다. 이 알고리즘 'HS256'이 뭔지도 조금 이따가 한번 살펴볼게요.
그리고 이 JSON은 Base64Url 인코딩되어 JWT의 첫 번째 부분을 형성한다. 그런 다음 Base64Url로 인코딩되어 있다고 하는데 Base64Uri는 암호화, 복호화 할 수 있는 암호화입니다.
이전 스프링 시큐리티 로그인 코드에서 사용한 암호화는 해싱이 되는 거기 때문에 복호화가 안됩니다. 비밀번호를 잊어버리면 비밀번호를 알아낼 수는 없고 초기화를 진행해야 합니다. 그게 해시입니다. 
이 Base64Url는 디코딩이 가능합니다. 암호화를 하고 나서 복호화를 할 수 있습니다. 

### 페이로드

토큰의 두 번째 부분은 클레임을 포함하는 페이로드입니다. 클레임은 3가지 등록된 클레임과 공개, 비공개 클레임 유형이 있습니다. 

등록된 클레임은 필수는 아니지만 권장되는 클레임 집합입니다. 그 중에는 iss(발행자), exp(만료시간), sub(대상), oud(청중) 등이 있다. 사실 안 넣어도 됩니다. 중요하지 않습니다. 

핵심을 이해하기 위해서는 페이로드에 무엇을 넣는지가 중요한데 우리는 Private 클레임을 넣어서 Private 클레임에 UserId 같은 정보를 넣어둘 것입니다. 그래서 이 JSON Web Token내 유저 정보에 필요한 공개돼도 되지만 그 유저인지를 특정할 수 있는 어떤 PrivateKey를 Private 클레임에 넣어줄 거예요. 

그래서 페이 로드의 얘는 다음과 같은데 이 sub랑 name 같은 것들은 아마 등록된 클레임일 거고요.

```JSON
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
이거 admin는 등록된 클레임이 아니라 Private 클레임 내가 원하면 만들어낼 수 있는 Key-Value 값이에요. 우리는 나중에 뭘 만들어 줄 거냐면 UserId는 1번 또는 2번 이런 내용들을 넣어줄 거예요. 그리고 User Name은 무엇이다.

그래서 다시 한 번 얘기하지만 헤더 부분에는 어떤 알고리즘을 사용해서 서명을 했는지에 대한 내용과 그리고 페이로드 부분에는 어떤 정보들을 담을 수 있습니다. 

### 서명

그리고 마지막에 서명 부분이 있는데 이 서명 부분에는 우리가 만들었던 헤더랑 그리고 페이로드 정보랑 그리고 어떤 Private Key(개인 키), 나만 알고 있는 어떤 Key 그 3개의 Key를 "HS256"으로 암호화를 해요. 

Secret, Private Key(개인 키)는 서버만 알고 있는 키입니다.

### HS256

HS256이라는 건 "HMAC SHA256"을 말해요.

예를 들어 HMAC SHA256 알고리즘을 사용하려는 경우 다음과 같은 방법으로 서명이 생성된다.
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```  

그렇게 해서 암호화를 하는데 이 SecretKey는 서버만 알고 있는 Key란 말이에요. 지금 구조를 봐도 이해가 안 갈 거예요. 이 구조를 어떤 예를 들어서 설명을 좀 드릴게요.

여기 Server와 Client가 있습니다. Client가 로그인하기 위해 아이디 / 비밀번호를 전송했습니다. 그럼 Server는 원래 세션을 만들었는데 세션 대신 JWT을 만듭니다. 
그럼 Server가 헤더를 만들고 페이로드를 만들고 시그니처를 만들어요. 

헤더에는 "HS256"가 담겨 있는데 "HS256" 으로 서명했다는 의미이고 페이로드에는 'username:jh'이 담겨져 있습니다. 
그리고 시그니처에는 '헤더정보 + 페이로드정보 + PrivateKey(ex:코스)'를 더해서 HS256으로 암호화한 값을 담습니다.

HS256이란 것은 HMAC SHA256으로 암호화하는 것입니다. SHA256는 Hash인데 복구할 수 없는 어떤 Key값을 만드는 것입니다. HMAC이란 SecretKey을 가진(포함한) 암호화 방식입니다.

PrivateKey(ex:코스)를 가지고 포함해서 암호화하면 HMAC암호화라고 할 수 있습니다. HMAC암호화 방식이 시크릿키를 포함한다는 것입니다.

그리고 각각을 Base64로 암호화합니다. 헤더를 Base64로 암호화하고 페이로드를 Base64로 암호화하고 시그니처(헤더+페이로드+시크릿키를 SHA256으로 해싱)를 Base64로 암호화합니다.
그래서 해당 내용을 클라이언트에게 돌려줍니다. 
 
로그인해서 인증이 완료되면 이 JWT를 생성합니다. 이 JWT는 암호화되있으므로 난수처럼 보이는데 클라이언트는 받아서 로컬스 토리지 같은 임시공간에 저장을 합니다. 

![image](https://user-images.githubusercontent.com/79847020/145748569-eb97b244-df9d-4980-b453-8420d09c973c.png)

저장을 해놓았다가 클라이언트가 새로운 요청, 예를 들면 '내 개인정보를 줘' 같은 요청을 하면서 JWT를 실어서 보냅니다. 로컬 스토리지에 저장한 JWT를 담아서 요청합니다. 서버에서 JWT을 받아서 이 JWT이 신뢰할 수 있는 토큰인지를 확인, 검증해야 됩니다. 

어떻게 검증을 하냐면 일단 JWT의 헤더와 페이로더 시그니처를 BASE64라고 디코드해서 확인할 수 있습니다. 하지만 담긴 정보가 중요한 것이 아니라 이 JWT이 유효한 Token인지를 검증 확인하는게 중요합니다. 그래서 서버에서 다시 헤더 + 페이로더 + SecretKey를 가지고 똑같이 HS256 암호화를 진행합니다. 그리고 클라이언트로부터 송신된 시그니처값과 비교하여 검증합니다. 

검증이 완료되면 페이로드에 담긴 Username을 사용해 개인정보를 보여줍니다. 

이 Signiture를 봤을 때 어떻게 만들어졌냐면 Header랑 Payload랑 Secret을 HMAC SHA256으로 암호화를 했단 말이에요. 
왜냐하면 HMAC이란 Secret을 하나 포함을 시켜가지고 암호화하는 방식이니까.

근데 RSA을 만약에 사용한다면 Server가 로그인 요청이 들어오면 헤더 만들고 헤더에 RSA라고 적어주고요. Payload에는 UserName:ID 라고 적어주고 Signiture를 만들 땐 Header랑 Payload만 Concat하고 Secret이 필요가 없어요. 

RSA에서는 Public Key(공개 키)랑 Private Key(개인 키)가 있잖아요. Server가 Private Key(개인 키)로 잠가버리면 돼요. Private Key(개인 키)로 잠가서 Signiture를 만들고 이걸 돌려줘요. 
그러면 이 Token을 Client가 받아가지고 다시 Server로 요청을 할 때 Token을 같이 던지면 Server는 검증 시에 Public Key(공개 키)로 Signiture를 복호화해서 확인만 하면 됩니다. 
Public Key(공개 키)로 Signiture을 검증하면 돼요. RSA로 해도 되고 HS256으로 해도 되는데 HS256을 더 많이 사용을 하더라고요. 

마지막으로 한번 복습할게요. 이게 좀 어렵거든요. 

이 JSON Web Token이 생긴 건 이런 식으로 생겼습니다. 

![image](https://user-images.githubusercontent.com/79847020/145767510-7afb72a5-b35b-46bf-8892-a74cbd64cc35.png)

빨간색이 Header예요. 보라색이 Payload고 파란색이 Signiture인데 각각 Base64로 암호화가 돼 있습니다. Base64로 암호화가 돼 있으면 얘들은 복호화가 가능합니다. Base64로 디코딩하면 이 데이터가 튀어나와요. 

Base64로 암호화가 돼 있으면 얘들은 복호화가 가능합니다. 

그러니까 한마디오 JWT는 암호화에 목적이 있는 게 아니에요. 서명에 목적이 있다는 거예요. 이 데이터가 유효한지 아닌지에 대한 무결성을 검증하기 위한 데이터지 이 데이터 자체가 어떤 비밀성을 보장하진 않는 다는거에요.
그래서 얘를 디버거를 사용해서 풀어보면 데이터를 확인할 수 있습니다.

![image](https://user-images.githubusercontent.com/79847020/145767915-e459f915-1b71-4d76-8f3a-88304aab15da.png)

JWT를 만들어서 Client한테 던지고 이 Client가 이 값을 들고 개인 정보를 요청할 때 그때 Server는 Base64로 다시 디코딩을 Header, Payload 데이터를 풀겠죠. 
그러면 다시 이 Header와 Payload와 자신만 알고 있는 Private Key(개인 키)를 토대로 HMAC SHA256을 해서 Signiture와 같으면 이 Token은 유효하다고 판단할 수 있는거에요.

이 Server들이 여러 개가 있을 수 있는데 세션을 사용하지 않고 Token 검증만 하면 돼기 때문에 서버들은 SecretKey만 알고 있으면 됩니다. 클라이언트의 요청이 서버1에 도달하든 서버2에 도달하든 요청에 대한 검증을 수행할 수 있기 때문에 아무런 상관이 없게 되는 겁니다.

왜냐하면 세션을 안 쓰잖아요. JWT Token만 검증만 하면 되기 때문에 각 서버들은 SecrectKey만 알고 있으면 됩니다. 

그래서 JWT Token을 요청과 함께 받으면 이 JWT을 검증하고 Payload에 있는 UserName 혹은 UserId 값으로 요청을 처리하면 됩니다. 
이 JWT는 아무나 만들 수가 없다는 거죠. 이거는 Server만 만들 수 있어요. 왜냐하면 Server가 만들어야지 유효한 값이 되기 때문입니다. 








