## HTTPS vs HTTP

  HTTPS는 Hypertext Trasfer Protocol의 약자다. 즉 Hypertext인 HTML을 전송하기 위한 통신규약을 의미한다. HTTPS에서 S는 Over Secure Socket Layer의 약자로 Secure라는 말을 통해서 알 수 있듯이 보안이 강화된 HTTP라는 것을 짐작할 수 있다. HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 제3자가 조작하거나 감청할 수 있습니다. 이를 보안한 것이 HTTPS입니다. 로그인할 때 아이디와 비밀번호가 HTTPS프로토콜로 전송이 되기 때문에 그 정보는 제3자로부터 안전할 수 있습니다. 그래서 서비스를 운영하는 입장에서도 HTTPS가 중요하지만 서비스를 이용하는 입장에서도 HTTPS가 중요합니다.
  
## HTTPS와 SSL

  HTTPS와 SSL를 같은 의미로 이해하고 있는 경우가 많은데 맞기도하고 틀리기도 합니다. 인터넷과 웹같은 관계라 말해도 무방합니다. 웹이 인터넷 위에서 돌아가는 거서럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜입니다.

  ![image](https://user-images.githubusercontent.com/79847020/167242319-6d4fb4c7-5676-476b-8dee-22fd0f669db7.png)
  
  HTTP가 제일 위에 있고 그 밑에 SSL/TLS라는 것이 있습니다. 그 밑에 TCP/IP가 존재합니다. 네트워크 통신할 때는 계층적으로 레이어라는 것이 구성되어 있어서 SSL 위에 HTTP, FTP, Telnet이 있습니다. SSL은 포괄적인 것이고 SSL이라는 통신 방법 위에서 동작하는 서비스 중 하나가 HTTP이고 HTTP가 SSL 위에서 동작하게 되면 HTTPS가 되는 것이다라고 생각하시면 됩니다. 
  
## SSL과 TLS

  같은 말이다. 네스케이프에 의해서 SSL이 발명되었고 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS1.0은 SSL3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.
  
## SSL 디지털 인증서

  SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.
  
  1. 통신 내용이 공격자에게 노출되는 것을 막을 수 있다.
  2. 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지를 판단할 수 있다.
  3. 통신 내용의 악의적인 변경을 방지할 수 있다.

## SSL에서 사용하는 암호화의 종류

  통신 내용이 공격자에게 노출 되는 것을 막기 위해서는 무엇을 해야할까요. 암호화가 필요합니다. SSL의 핵심은 암호화다. SSL은 보안과 성능상의 이유로 두가지 암호화 기법을 혼용해서 사용하고 있습니다. 공격자에게 통신 내용이 노출되더라도 공격자가 통신 내용을 해석할 수 없게하고, 목적지에 정상적으로 도달한 경우에는 해석할 수 있도록 하는 것이 암호화입니다. 
  
  내용을 제3자가 알아보지 못하도록 바꾸는 것을 `암호화`, 암호화 된 내용을 다시 원상태로 되돌리는 것을 `복호화`라고 합니다. 그리고 암호화와 복호화를 하기 위해 사용되는 데이터를 `키`라고 합니다. `키`를 가지고 있어야만 암호화와 복호화를 할 수 있습니다. 키가 없다면 내용을 알 수 없도록 하는 것이 암호화의 기본 메커니즘 입니다. 이런 방식의 암호화를 `대칭키`라고 합니다. 대칭키라는 것은 암호화를 할 때와 복호화를 할 때 같은 키를 사용한다는 것을 의미합니다. 
  
## 대칭키

  암호를 만드는 행위인 암호화를 할 때 사용하는 일종의 비밀번호를 키(key)라고 한다. 이 키에 따라서 암호화된 결과가 달라지기 때문에 키를 모르면 암호를 푸는 행위인 복호화를 할 수 없다. 대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다. 
  
  openssl 프로그램을 사용해서 실습을 해보겠습니다. http://slproweb.com/products/Win32OpenSSL.html 사이트에서 Win64 OpenSSL v1.1.1o를 설치합니다.  
  
  ```
  C:\study\work\https>echo 'this is the plain text' > plaintext.txt;

  C:\study\work\https>dir
  C 드라이브의 볼륨에는 이름이 없습니다.
   볼륨 일련 번호: 1AEF-2526

  C:\study\work\https 디렉터리

  2022-05-07  오후 07:57    <DIR>          .
  2022-05-07  오후 07:57    <DIR>          ..
  2022-05-07  오후 07:57                28 plaintext.txt
                 1개 파일                  28 바이트
                 2개 디렉터리  668,420,591,616 바이트 남음

  C:\study\work\https>openssl enc -e -des3 -salt -in plaintext.txt -out ciphertext.bin;
  enter des-ede3-cbc encryption password:
  Verifying - enter des-ede3-cbc encryption password:
  *** WARNING : deprecated key derivation used.
  Using -iter or -pbkdf2 would be better.
  ```                 
                 
  * openssl enc -e -des3 : des3 방식으로 암호화 함 (des3는 대칭키 암호화 방법 중 하나, SSL에서 사용하는 암호화 기법)
  * -in plaintext.txt -out ciphertext.bin : plaintext.txt 파일을 암호화 한 결과를 ciphertext.bin 파일에 저장함

  ciphertext  
  ```
  Salted__d?럶???	?F?d?9?볾N괩?퉋E?r
  ```
  
  ciphertext.bin는 des-ede3-cbc encryption password로 입력한 Key를 가지고 있지 않은 사람이라면 복호화 할 수 없습니다. 이 방식은 자기가 가지고 있는 Key를 통해서 암호화할 때 사용하는 방법 입니다. 개인이 사용할 때 해당 방법은 유용하게 사용할 수 있습니다. 그런데 ciphertext.bin을 멀리 있는 사람에게 전송을 하는 경우 경유지가 많아지고 ciphertext.bin이 노출될 가능성이 커집니다. 암호화가 되어있기 때문에 누군가가 가로채도 해독하는 것이 어렵습니다. 문제는 암호를 멀리 있는 사람이 복호화하려면 지정했던 Key를 알아야 된다는 겁니다. 멀리있는 사람에게 Key값을 전송해야 된다는 의미이기 때문에 `Key값이 유출될 경우 누구든 복호화할 수 있다는 문제점`이 있습니다. 이것이 대칭키 방식의 가장 치명적인 단점입니다. 그래서 대칭키 암호화 방식을 보완한 공개키 암호화 방식이 도입됩니다. 참고로 SSL은 대칭키 방식과 공개키 방식이 혼합되서 사용됩니다.
  
## 공개키

  대칭키 방식은 단점이 있다. 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다는 점이다. 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다. 이런 배경에서 나온 암호화 방식이 공개키방식이다. `공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식`이다. 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 
  
  `비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공`한다. 공개키는 노출된다. 공개키를 제공 받은 타인은 `공개키를 이용해서 정보를 암호화`한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다. 이 방식의 장점은 Key를 전송하는 과정이 없다는 것입니다.
  
  공개키를 통해서 인증하는 방법에 대해서 생각해보자. 인증이란 것은 자신이 받은 정보가 올바른(예상된) 사람이 전송한 정보가 맞는지를 확인하는 것이 인증입니다. 
  
  비공개키의 소유자는 비공개키를 이용해서 정보를 암호화 한 후에 공개키와 함께 암호화된 정보를 전송한다. 정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다면 의도하지 않은 공격자에 의해서 데이터가 복호화 될 위험이 있다. 이런 위험에도 불구하고 `비공개키를 이용해서 암호화를 하는 이유`는 무엇일까? 그것은 이것이 데이터를 보호하는 것이 목적이 아니기 때문이다. `암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화 되었다는 것을 의미`한다. 즉 `공개키가 데이터를 제공한 사람의 신원을 보장해주게 되는 것`이다. 이러한 것을 `전자 서명`이라고 부른다.
  
### RSA 공개키  

  공개키를 이용해서 RSA라는 방식의 공개키를 사용해보자. 

  1. GEN RSA : private.pem 비공개키 생성, 이 키는 1024bit 길이을 갖는다. 이 숫자가 높을수록 안전하다.
  ```
  openssl genrsa -out private.pem 1024;
  ```
  2. RSA : private.pem 비공개키에 대한 public.pem공개키를 생성한다. 이 공개키를 자신에게 정보를 제공할 사람에게 전송하면 된다.
  ```
  openssl rsa -in private.pem -out public.pem -outform PEM -pubout;
  ```
  3. 공개키를 가진 사람이 어떤 정보를 비공개키를 가지고 있는 사람에게 전송하는 상황을 상정해보자. 아래는 coding everybody라는 이름의 문자를 담고 있는 file.txt를 만든다. 이 데이터를 비공개키 소유자에게 전송하기 위해서는 암호화가 필요하다.
  ```
  echo 'coding everybody' > file.txt
  ```
  4. RSA UTL : file.txt를 암호화 해보자. 아래의 예제는 file.txt의 내용을 RSA방식으로 암호화한 file.ssl이라는 이름의 파일을 생성한다. 이 때 사용된 공개키가 public.pem이다. 이제 안심하고 file.txt를 암호화한 결과인 file.ssl을 비공개키의 소유자에게 전송할 수 있다.
  ```
  openssl rsautl -encrypt -inkey public.pem -pubin -in file.txt -out file.ssl;
  ```
  5. RSA UTL : 그럼 file.ssl을 수신받은 비공개키 소유자가 어떻게 이 정보를 복호화 할 수 있는지 알아보자. 아래 예제는 file.ssl을 복호화한 결과를 decrypted.txt로 만들어내는 방법을 보여준다. 이 과정에서 비공개키인 private.pem을 사용했다.
  ```
  openssl rsautl -decrypt -inkey private.pem -in file.ssl -out decrypted.txt
  ```
  
  SSL을 이용하는데 핵심이 되는 암호화기법에 대해서 알아보았습니다. 이 암호화 기법들을 사용해서 결국 SSL이라는 개념이 만들어졌고 이를 이해해야 SSL을 좀 더 깊게 이해할 수 있습니다.
  
## SSL 인증서

  인증서의 기능은 크게 두가지다. 이 두가지를 이해하는 것이 인증서를 이해하는 핵심이다.

  1. 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.
  2. SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

## CA

  인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부른다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여할 수 있다. 그 중에 대표적인 기업들은 아래와 같다. 수치는 현시점의 시장점유율이다. (위키피디아 참조)

  Symantec (VeriSign, Thawte, Geotrust) with 42.9% market share
  Comodo with 26%
  GoDaddy with 14%
  GlobalSign with 7.7%

  SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해서 인증서를 구입해야 한다. CA는 서비스의 신뢰성을 다양한 방법으로 평가하게 된다. 이런 업체들의 인증서로 사이트의 신뢰성을 보장받게 되는데 서비스를 운영하기 위해서는 그 업체들로부터 비용을 지불해서 인증서를 구입해야 합니다. 참고로 무료로 인증서를 사용할 수 있는 방법도 있습니다.
  
## 사설 인증기관
  
  인증서라는 것은 결국 클라이언트와 서버가 서로 신뢰할 수 없는 관계인데 중간에서 권위가 있는 기관이 필요한 것입니다. 여러분이 직접 사용하는 서버, 개발 서버나 사내에서 사용하는 서버인 경우에는 굳이 인증서를 구입할 필요가 없습니다. 왜냐하면 그 도메인이 그 사이트라는 것을 충분히 인지하고 있기 때문입니다. 그 사이트에 대한 신뢰성은 이미 확보가 되어있는 상태에서 인증 SSL이라는 프로토콜이 제공하고 있는 보안 기능, 암호화 기능을 사용하고 싶은 경우에는 직접 자신이 아까 말씀드렸던 CA의 역할을 스스로 하면서 SSL을 사용할 수 있는 방법이 있습니다. 그 방법을 사용하면 비용도 들지 않고 아주 빠르게 SSL을 사용할 수 있는 장점이 있습니다. 그런데 공인된 업체에서 제공하는 것이 아니기 때문에 여러분들이 이것을 사적인 서비스가 아니라 퍼블릿한 서비스에서는 이 방법을 사용하면 안됩니다.
  
  개발이나 사적인 목적을 위해서 SSL의 암호화 기능을 이용하려한다면 자신이 직접 CA의 역할을 할 수도 있다. 물론 이것은 공인된 인증서가 아니기 때문에 이러한 사설 CA의 인증서를 이용하는 경우 브라우저는 아래와 같은 경고를 출력한다.

![image](https://user-images.githubusercontent.com/79847020/167421570-900c05db-ce9e-4807-a912-b16781b40d10.png)

  공인된 CA가 제공하는 인증서를 사용한다면 브라우저의 주소창이 아래와 비슷한 모양을 보여줄 것이다.

![image](https://user-images.githubusercontent.com/79847020/167421589-cda8b8e7-c6c1-4531-8242-98ad427ecfd0.png)

## SSL 인증서의 내용

  SSL 인증서에는 다음과 같은 정보가 포함되어 있다.

  1. 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)
  2. 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)

  인증서의 내용은 위와 같이 크게 2가지로 구분할 수 있다. 1번은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용을 담고 있고, 2번은 서버와 통신을 할 때 사용할 공개키와 그 공개키의 암호화 방법들의 정보를 담고 있다. 서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 한다.
  
  그러면 인증서는 어떻게 클라이언트에게 전달이 되냐면 웹 브라우저가 SSL 프로토콜을 이용해서 접속을 하게 되면 내부적으로 서비스는 서비스 인증서를 클라이언트에게 전송해줍니다. 예를 들어서 http://google.com은 http영역인데 로그인 버튼을 누르면 https프로토콜로 접속을 하게 됩니다. 그러면 웹 브라우저는 해당 페이지에 접속을 할 때 SSL로 접속을 했다는 것이고 내부적으로 구글 서버는 클라이언트에게 SSL인증서를 전송을 해주게 되는 것입니다. 
  
  ![image](https://user-images.githubusercontent.com/79847020/167426637-f1ab4fe3-3d85-4fb6-93bd-d11c6865e49d.png)
  
  인증 아이콘을 누르면 인증서 정보를 확인할 수 있습니다. 인증 유효 기간, 주체, 발급자, 암호화 방식에 대한 정보들을 확인할 수 있습니다.
  
  ![image](https://user-images.githubusercontent.com/79847020/167426857-2ab9a03b-7075-4557-9cc5-df0c4faf5a40.png)
  
  정리하면 클라이언트가 접속했을 때 서버는 자신이 가지고 있는 인증서를 클라이언트에게 전송을 해줍니다. 인증서는 공인된 기관 CA에 의뢰해서 구입하게 됩니다. 그 때 사이트의 목적, 높은 수준의 보안 서비스를 제공하는 인증서의 경우에는 사업자 등록번호라든지 불법적인 행위를 하지 않는다는 것을 서류를 보내게 됩니다. 그리고 서버는 자기가 생성한 공개키를 같이 인증기관에게 보내게 됩니다. 자신은 비밀키를 가지고 있고 공개키를 만들어서 공개키와 자신의 서비스에 대한 정보를 담아서 인증기관에게 전송하면 인증기관은 인증정보를 심의해서 문제가 없다고 판단되면 인증서를 서비스에게 제공하는 것입니다. 그러면 서비스 제공자는 자신의 서비스를 접속하는 사용자들에게 그 인증서를 제공하는 것을 통해서 SSL 프로토콜을 사용할 수 있게 됩니다. 
  
## CA를 브라우저는 알고 있다

  인증기관에 대한 정보는 브라우저가 이미 알고 있습니다. 성능상의 이유도 있고 여러가지 이유로 인해서 브라우저는 어떤 기관이 공인된 기관인지에 대한 정보를 가지고 있습니다. 정확하게는 루트 인증 기관에 대한 정보를 브라우저는 알고 있습니다. 
  
  인증서를 이해하는데 꼭 알고 있어야 하는 것이 CA의 리스트다. 브라우저는 내부적으로 CA의 리스트를 미리 파악하고 있다. 이 말은 브라우저의 소스코드 안에 CA의 리스트가 들어있다는 것이다. 브라우저가 미리 파악하고 있는 CA의 리스트에 포함되어야만 공인된 CA가 될 수 있는 것이다. CA의 리스트와 함께 각 CA의 공개키를 브라우저는 이미 알고 있다.
  
## SSL 인증서가 서비스를 보증하는 방법

  웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공합니다. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인합니다. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 합니다. CA의 공개키를 이용해서 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화 된 것을 의마한다. 해당 CA의 비공개 키를 가지고 있는 CA는 해당 CA밖에는 없기 때문에 서버가 제공한 인증서가 CA에 의해서 발급된 것이라는 것을 의미한다. CA에 의해서 발급된 인증서라는 것은 접속한 사이트가 CA에 의해서 검토되었다는 것을 의미하게 된다. CA의 검토를 통과했다는 것은 해당 서브시가 신뢰할 수 있다는 것을 의미한다. 이것이 CA와 브라우저가 특정 서버를 인증하는 과정이다. 
  
  이렇게 해서 인증서가 서버의 신뢰성을 제공하는 방법을 알아보았다. 그런데 의문점이 남는다. 인증서에 포함된 서버의 공개키는 어떤 용도에 사용될까?
  
## SSL의 동작방법

  결론부터 말하면 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용합니다. 즉 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화하고 대칭키 방식으로 암호화 된 실제 정보를 복호화 할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이어늩와 서버가 주고 받습니다.
  
  * 실제 데이터 : 대칭키
  * 대칭키의 키 : 공개키

컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있습니다. 

  악수(Handshake) -> 전송(Session) -> 세션종료
  
이 과정에서 SSL가 어떻게 데이터를 암호화해서 전달하는지 살펴보자.

1. 악수(HandShake)

  사람과 사람이 소통을 할 때 인사를 하고 서로 통성명을 하는 것처럼 클라이언트와 서버도 마찬가지이다. 실제 데이터를 주고 받기전에 클라이언트와 서버는 일종의 인사인 Handshake를 한다. 이 과정을 통해서 서로 상대방이 존재하는지 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용하는지 파악한다.
  
  SSL방식을 이용해서 통신을 하는 부라우저와 서버 역시 Handshake를 하는데 이 때 SSL 인증서를 주고 받는다. 이 과정은 앞에서 설명한 바 있다. 인증서에 포함된 서버 측 공개키의 역할을 무엇일까를 살펴보자.
  
  공개키는 이상적인 통신 방법이다. 암호화와 복호화를 할 때 사용하는 키가 서로 다르기 때문에 



  
  
  
  

  
  
  
  
  
